## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry and imagePullSecrets
##
global:
  postgresql: {}
#   imageRegistry: myRegistryName
#   imagePullSecrets:
#     - myRegistryKeySecretName

## Bitnami PostgreSQL image version
## ref: https://hub.docker.com/r/bitnami/postgresql/tags/
##
image:
  registry: docker.io
  repository: bitnami/postgresql
  tag: 11.3.0-debian-9-r38
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
  ##
  pullPolicy: Always
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  # pullSecrets:
  #   - myRegistryKeySecretName

  ## Set to true if you would like to see extra information on logs
  ## It turns BASH and NAMI debugging in minideb
  ## ref:  https://github.com/bitnami/minideb-extras/#turn-on-bash-debugging
  debug: true

##
## Init containers parameters:
## volumePermissions: Change the owner of the persist volume mountpoint to RunAsUser:fsGroup
##
volumePermissions:
  enabled: true
  image:
    registry: docker.io
    repository: bitnami/minideb
    tag: latest
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    ##
    pullPolicy: Always
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName
  ## Init container Security Context
  securityContext:
    runAsUser: 0

## Use an alternate scheduler, e.g. "stork".
## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
##
# schedulerName:

## Pod Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
##
securityContext:
  enabled: true
  fsGroup: 1001
  runAsUser: 1001

## Pod Service Account
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
serviceAccount:
  enabled: false
  ## Name of an already existing service account. Setting this value disables the automatic service account creation.
  # name:

replication:
  enabled: false
  user: repl_user
  password: repl_password
  slaveReplicas: 1
  ## Set synchronous commit mode: on, off, remote_apply, remote_write and local
  ## ref: https://www.postgresql.org/docs/9.6/runtime-config-wal.html#GUC-WAL-LEVEL
  synchronousCommit: "off"
  ## From the number of `slaveReplicas` defined above, set the number of those that will have synchronous replication
  ## NOTE: It cannot be > slaveReplicas
  numSynchronousReplicas: 0
  ## Replication Cluster application name. Useful for defining multiple replication policies
  applicationName: my_application

## PostgreSQL admin user
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
postgresqlUsername: wso2carbon

## PostgreSQL password
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
##
postgresqlPassword: wso2carbon

## PostgreSQL password using existing secret
## existingSecret: secret

## Mount PostgreSQL secret as a file instead of passing environment variable
# usePasswordFile: false

## Create a database
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#creating-a-database-on-first-run
##
postgresqlDatabase: wso2carbon

## PostgreSQL data dir
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
##
postgresqlDataDir: /bitnami/postgresql/data

## Specify extra initdb args
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
##
# postgresqlInitdbArgs:

## Specify a custom location for the PostgreSQL transaction log
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
##
# postgresqlInitdbWalDir:


## PostgreSQL configuration
## Specify runtime configuration parameters as a dict, using camelCase, e.g.
## {"sharedBuffers": "500MB"}
## Alternatively, you can put your postgresql.conf under the files/ directory
## ref: https://www.postgresql.org/docs/current/static/runtime-config.html
##
# postgresqlConfiguration:

## PostgreSQL extended configuration
## As above, but _appended_ to the main configuration
## Alternatively, you can put your *.conf under the files/conf.d/ directory
## https://github.com/bitnami/bitnami-docker-postgresql#allow-settings-to-be-loaded-from-files-other-than-the-default-postgresqlconf
##
# postgresqlExtendedConf:

## PostgreSQL client authentication configuration
## Specify content for pg_hba.conf
## Default: do not create pg_hba.conf
## Alternatively, you can put your pg_hba.conf under the files/ directory
# pgHbaConfiguration: |-
#   local all all trust
#   host all all localhost trust
#   host mydatabase mysuser 192.168.0.0/24 md5

## ConfigMap with PostgreSQL configuration
## NOTE: This will override postgresqlConfiguration and pgHbaConfiguration
# configurationConfigMap:

## ConfigMap with PostgreSQL extended configuration
# extendedConfConfigMap:

## initdb scripts
## Specify dictionary of scripts to be run at first boot
## Alternatively, you can put your scripts under the files/docker-entrypoint-initdb.d directory
##
# initdbScripts:
#   my_init_script.sh: |
#      #!/bin/sh
#      echo "Do something."

initdbScripts:
  init.sql: |
      DROP DATABASE IF EXISTS wso2ei_user_db;
      DROP DATABASE IF EXISTS wso2ei_integrator_gov_db;
      DROP DATABASE IF EXISTS wso2_cluster_db;
      DROP DATABASE IF EXISTS ei_analytics;
      DROP DATABASE IF EXISTS wso2_carbon_db;
      DROP DATABASE IF EXISTS wso2_persistence_db;


      CREATE DATABASE wso2ei_user_db;
      CREATE DATABASE wso2ei_integrator_gov_db;
      CREATE DATABASE wso2_cluster_db;
      CREATE DATABASE ei_analytics;
      CREATE DATABASE wso2_carbon_db;
      CREATE DATABASE wso2_persistence_db;

      \c wso2ei_user_db;

      DROP TABLE IF EXISTS REG_CLUSTER_LOCK;
      CREATE TABLE REG_CLUSTER_LOCK (
                   REG_LOCK_NAME VARCHAR (20),
                   REG_LOCK_STATUS VARCHAR (20),
                   REG_LOCKED_TIME TIMESTAMP,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (REG_LOCK_NAME)
      );

      DROP TABLE IF EXISTS REG_LOG;
      DROP SEQUENCE IF EXISTS REG_LOG_PK_SEQ;
      CREATE SEQUENCE REG_LOG_PK_SEQ;
      CREATE TABLE REG_LOG (
                   REG_LOG_ID INTEGER DEFAULT NEXTVAL('REG_LOG_PK_SEQ'),
                   REG_PATH VARCHAR (2000),
                   REG_USER_ID VARCHAR (31) NOT NULL,
                   REG_LOGGED_TIME TIMESTAMP NOT NULL,
                   REG_ACTION INTEGER NOT NULL,
                   REG_ACTION_DATA VARCHAR (500),
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (REG_LOG_ID, REG_TENANT_ID)
      );

      CREATE INDEX REG_LOG_IND_BY_REG_LOGTIME ON REG_LOG(REG_LOGGED_TIME, REG_TENANT_ID);

      DROP TABLE IF EXISTS REG_PATH;
      DROP SEQUENCE IF EXISTS REG_PATH_PK_SEQ;
      CREATE SEQUENCE REG_PATH_PK_SEQ;
      CREATE TABLE REG_PATH(
                   REG_PATH_ID INTEGER DEFAULT NEXTVAL('REG_PATH_PK_SEQ'),
                   REG_PATH_VALUE VARCHAR(2000) NOT NULL,
                   REG_PATH_PARENT_ID INTEGER,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   CONSTRAINT PK_REG_PATH PRIMARY KEY(REG_PATH_ID, REG_TENANT_ID)
      );

      CREATE INDEX REG_PATH_IND_BY_PATH_VALUE ON REG_PATH(REG_PATH_VALUE, REG_TENANT_ID);
      CREATE INDEX REG_PATH_IND_BY_PATH_PARENT_ID  ON REG_PATH(REG_PATH_PARENT_ID, REG_TENANT_ID);

      DROP TABLE IF EXISTS REG_CONTENT;
      DROP SEQUENCE IF EXISTS REG_CONTENT_PK_SEQ;
      CREATE SEQUENCE REG_CONTENT_PK_SEQ;
      CREATE TABLE REG_CONTENT (
                   REG_CONTENT_ID INTEGER DEFAULT NEXTVAL('REG_CONTENT_PK_SEQ'),
                   REG_CONTENT_DATA BYTEA,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   CONSTRAINT PK_REG_CONTENT PRIMARY KEY(REG_CONTENT_ID, REG_TENANT_ID)
      );

      DROP TABLE IF EXISTS REG_CONTENT_HISTORY;
      CREATE TABLE REG_CONTENT_HISTORY (
                   REG_CONTENT_ID INTEGER NOT NULL,
                   REG_CONTENT_DATA BYTEA,
                   REG_DELETED   SMALLINT,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   CONSTRAINT PK_REG_CONTENT_HISTORY PRIMARY KEY(REG_CONTENT_ID, REG_TENANT_ID)
      );

      DROP TABLE IF EXISTS REG_RESOURCE;
      DROP SEQUENCE IF EXISTS REG_RESOURCE_PK_SEQ;
      CREATE SEQUENCE REG_RESOURCE_PK_SEQ;
      CREATE TABLE REG_RESOURCE (
                  REG_PATH_ID         INTEGER NOT NULL,
                  REG_NAME            VARCHAR(256),
                  REG_VERSION         INTEGER DEFAULT NEXTVAL('REG_RESOURCE_PK_SEQ'),
                  REG_MEDIA_TYPE      VARCHAR(500),
                  REG_CREATOR         VARCHAR(31) NOT NULL,
                  REG_CREATED_TIME    TIMESTAMP NOT NULL,
                  REG_LAST_UPDATOR    VARCHAR(31),
                  REG_LAST_UPDATED_TIME    TIMESTAMP NOT NULL,
                  REG_DESCRIPTION     VARCHAR(1000),
                  REG_CONTENT_ID      INTEGER,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  REG_UUID VARCHAR(100) NOT NULL,
                  CONSTRAINT PK_REG_RESOURCE PRIMARY KEY(REG_VERSION, REG_TENANT_ID)
      );

      ALTER TABLE REG_RESOURCE ADD CONSTRAINT REG_RESOURCE_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE ADD CONSTRAINT REG_RESOURCE_FK_BY_CONTENT_ID FOREIGN KEY (REG_CONTENT_ID, REG_TENANT_ID) REFERENCES REG_CONTENT (REG_CONTENT_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_IND_BY_NAME  ON REG_RESOURCE(REG_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_IND_BY_PATH_ID_NAME  ON REG_RESOURCE(REG_PATH_ID, REG_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_IND_BY_UUID  ON REG_RESOURCE(REG_UUID);
      CREATE INDEX REG_RESOURCE_IND_BY_TENANT ON REG_RESOURCE(REG_TENANT_ID, REG_UUID);
      CREATE INDEX REG_RESOURCE_IND_BY_TYPE ON REG_RESOURCE(REG_TENANT_ID, REG_MEDIA_TYPE);

      DROP TABLE IF EXISTS REG_RESOURCE_HISTORY;
      CREATE TABLE REG_RESOURCE_HISTORY (
                  REG_PATH_ID         INTEGER NOT NULL,
                  REG_NAME            VARCHAR(256),
                  REG_VERSION         INTEGER NOT NULL,
                  REG_MEDIA_TYPE      VARCHAR(500),
                  REG_CREATOR         VARCHAR(31) NOT NULL,
                  REG_CREATED_TIME    TIMESTAMP NOT NULL,
                  REG_LAST_UPDATOR    VARCHAR(31),
                  REG_LAST_UPDATED_TIME    TIMESTAMP NOT NULL,
                  REG_DESCRIPTION     VARCHAR(1000),
                  REG_CONTENT_ID      INTEGER,
                  REG_DELETED         SMALLINT,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  REG_UUID VARCHAR(100) NOT NULL,
                  CONSTRAINT PK_REG_RESOURCE_HISTORY PRIMARY KEY(REG_VERSION, REG_TENANT_ID)
      );

      ALTER TABLE REG_RESOURCE_HISTORY ADD CONSTRAINT REG_RESOURCE_HIST_FK_BY_PATHID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_HISTORY ADD CONSTRAINT REG_RESOURCE_HIST_FK_BY_CONTENT_ID FOREIGN KEY (REG_CONTENT_ID, REG_TENANT_ID) REFERENCES REG_CONTENT_HISTORY (REG_CONTENT_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_HISTORY_IND_BY_NAME  ON REG_RESOURCE_HISTORY(REG_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_HISTORY_IND_BY_PATH_ID_NAME  ON REG_RESOURCE(REG_PATH_ID, REG_NAME, REG_TENANT_ID);

      DROP TABLE IF EXISTS REG_COMMENT;
      DROP SEQUENCE IF EXISTS REG_COMMENT_PK_SEQ;
      CREATE SEQUENCE REG_COMMENT_PK_SEQ;
      CREATE TABLE REG_COMMENT (
                  REG_ID        INTEGER DEFAULT NEXTVAL('REG_COMMENT_PK_SEQ'),
                  REG_COMMENT_TEXT      VARCHAR(500) NOT NULL,
                  REG_USER_ID           VARCHAR(31) NOT NULL,
                  REG_COMMENTED_TIME    TIMESTAMP NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_COMMENT PRIMARY KEY(REG_ID, REG_TENANT_ID)
      );

      DROP TABLE IF EXISTS REG_RESOURCE_COMMENT;
      CREATE TABLE REG_RESOURCE_COMMENT (
                  REG_COMMENT_ID          INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      );

      ALTER TABLE REG_RESOURCE_COMMENT ADD CONSTRAINT REG_RESOURCE_COMMENT_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_COMMENT ADD CONSTRAINT REG_RESOURCE_COMMENT_FK_BY_COMMENT_ID FOREIGN KEY (REG_COMMENT_ID, REG_TENANT_ID) REFERENCES REG_COMMENT (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_COMMENT_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_COMMENT(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_COMMENT_IND_BY_VERSION  ON REG_RESOURCE_COMMENT(REG_VERSION, REG_TENANT_ID);

      DROP TABLE IF EXISTS REG_RATING;
      DROP SEQUENCE IF EXISTS REG_RATING_PK_SEQ;
      CREATE SEQUENCE REG_RATING_PK_SEQ;
      CREATE TABLE REG_RATING (
                  REG_ID     INTEGER DEFAULT NEXTVAL('REG_RATING_PK_SEQ'),
                  REG_RATING        INTEGER NOT NULL,
                  REG_USER_ID       VARCHAR(31) NOT NULL,
                  REG_RATED_TIME    TIMESTAMP NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_RATING PRIMARY KEY(REG_ID, REG_TENANT_ID)
      );

      DROP TABLE IF EXISTS REG_RESOURCE_RATING;
      CREATE TABLE REG_RESOURCE_RATING (
                  REG_RATING_ID           INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      );

      ALTER TABLE REG_RESOURCE_RATING ADD CONSTRAINT REG_RESOURCE_RATING_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_RATING ADD CONSTRAINT REG_RESOURCE_RATING_FK_BY_RATING_ID FOREIGN KEY (REG_RATING_ID, REG_TENANT_ID) REFERENCES REG_RATING (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_RATING_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_RATING(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_RATING_IND_BY_VERSION  ON REG_RESOURCE_RATING(REG_VERSION, REG_TENANT_ID);

      DROP TABLE IF EXISTS REG_TAG;
      DROP SEQUENCE IF EXISTS REG_TAG_PK_SEQ;
      CREATE SEQUENCE REG_TAG_PK_SEQ;
      CREATE TABLE REG_TAG (
                  REG_ID         INTEGER DEFAULT NEXTVAL('REG_TAG_PK_SEQ'),
                  REG_TAG_NAME       VARCHAR(500) NOT NULL,
                  REG_USER_ID        VARCHAR(31) NOT NULL,
                  REG_TAGGED_TIME    TIMESTAMP NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_TAG PRIMARY KEY(REG_ID, REG_TENANT_ID)
      );

      DROP TABLE IF EXISTS REG_RESOURCE_TAG;
      CREATE TABLE REG_RESOURCE_TAG (
                  REG_TAG_ID              INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      );

      ALTER TABLE REG_RESOURCE_TAG ADD CONSTRAINT REG_RESOURCE_TAG_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_TAG ADD CONSTRAINT REG_RESOURCE_TAG_FK_BY_TAG_ID FOREIGN KEY (REG_TAG_ID, REG_TENANT_ID) REFERENCES REG_TAG (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_TAG_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_TAG(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_TAG_IND_BY_VERSION  ON REG_RESOURCE_TAG(REG_VERSION, REG_TENANT_ID);

      DROP TABLE IF EXISTS REG_PROPERTY;
      DROP SEQUENCE IF EXISTS REG_PROPERTY_PK_SEQ;
      CREATE SEQUENCE REG_PROPERTY_PK_SEQ;
      CREATE TABLE REG_PROPERTY (
                  REG_ID         INTEGER DEFAULT NEXTVAL('REG_PROPERTY_PK_SEQ'),
                  REG_NAME       VARCHAR(100) NOT NULL,
                  REG_VALUE        VARCHAR(1000),
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_PROPERTY PRIMARY KEY(REG_ID, REG_TENANT_ID)
      );

      DROP TABLE IF EXISTS REG_RESOURCE_PROPERTY;
      CREATE TABLE REG_RESOURCE_PROPERTY (
                  REG_PROPERTY_ID         INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      );

      ALTER TABLE REG_RESOURCE_PROPERTY ADD CONSTRAINT REG_RESOURCE_PROPERTY_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_PROPERTY ADD CONSTRAINT REG_RESOURCE_PROPERTY_FK_BY_TAG_ID FOREIGN KEY (REG_PROPERTY_ID, REG_TENANT_ID) REFERENCES REG_PROPERTY (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_PROPERTY_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_PROPERTY(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_PROPERTY_IND_BY_VERSION  ON REG_RESOURCE_PROPERTY(REG_VERSION, REG_TENANT_ID);


      DROP TABLE IF EXISTS REG_ASSOCIATION;
      DROP SEQUENCE IF EXISTS REG_ASSOCIATION_PK_SEQ;
      CREATE SEQUENCE REG_ASSOCIATION_PK_SEQ;
      CREATE TABLE REG_ASSOCIATION (
                  REG_ASSOCIATION_ID INTEGER DEFAULT NEXTVAL('REG_ASSOCIATION_PK_SEQ'),
                  REG_SOURCEPATH VARCHAR (2000) NOT NULL,
                  REG_TARGETPATH VARCHAR (2000) NOT NULL,
                  REG_ASSOCIATION_TYPE VARCHAR (2000) NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (REG_ASSOCIATION_ID, REG_TENANT_ID)
      );

      DROP TABLE IF EXISTS REG_SNAPSHOT;
      DROP SEQUENCE IF EXISTS REG_SNAPSHOT_PK_SEQ;
      CREATE SEQUENCE REG_SNAPSHOT_PK_SEQ;
      CREATE TABLE REG_SNAPSHOT (
                  REG_SNAPSHOT_ID     INTEGER DEFAULT NEXTVAL('REG_SNAPSHOT_PK_SEQ'),
                  REG_PATH_ID            INTEGER NOT NULL,
                  REG_RESOURCE_NAME      VARCHAR(255),
                  REG_RESOURCE_VIDS     BYTEA NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_SNAPSHOT PRIMARY KEY(REG_SNAPSHOT_ID, REG_TENANT_ID)
      );

      CREATE INDEX REG_SNAPSHOT_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_SNAPSHOT(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);

      ALTER TABLE REG_SNAPSHOT ADD CONSTRAINT REG_SNAPSHOT_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);


      -- ################################
      -- USER MANAGER TABLES
      -- ################################

      DROP TABLE IF EXISTS UM_TENANT;
      DROP SEQUENCE IF EXISTS UM_TENANT_PK_SEQ;
      CREATE SEQUENCE UM_TENANT_PK_SEQ;
      CREATE TABLE UM_TENANT (
      			UM_ID INTEGER DEFAULT NEXTVAL('UM_TENANT_PK_SEQ'),
      			UM_DOMAIN_NAME VARCHAR(255) NOT NULL,
                  UM_EMAIL VARCHAR(255),
                  UM_ACTIVE BOOLEAN DEFAULT FALSE,
      	        UM_CREATED_DATE TIMESTAMP NOT NULL,
      	        UM_USER_CONFIG BYTEA,
      			PRIMARY KEY (UM_ID),
      			UNIQUE(UM_DOMAIN_NAME));

      CREATE INDEX INDEX_UM_TENANT_UM_DOMAIN_NAME
                          ON UM_TENANT (UM_DOMAIN_NAME);


      DROP TABLE IF EXISTS UM_DOMAIN;
      DROP SEQUENCE IF EXISTS UM_DOMAIN_PK_SEQ;
      CREATE SEQUENCE UM_DOMAIN_PK_SEQ;
      CREATE TABLE UM_DOMAIN(
                  UM_DOMAIN_ID INTEGER DEFAULT NEXTVAL('UM_DOMAIN_PK_SEQ'),
                  UM_DOMAIN_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (UM_DOMAIN_ID, UM_TENANT_ID)
      );


      DROP TABLE IF EXISTS UM_USER CASCADE;
      DROP SEQUENCE IF EXISTS UM_USER_PK_SEQ;
      CREATE SEQUENCE UM_USER_PK_SEQ;
      CREATE TABLE UM_USER (
                   UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_PK_SEQ'),
                   UM_USER_NAME VARCHAR(255) NOT NULL,
                   UM_USER_PASSWORD VARCHAR(255) NOT NULL,
                   UM_SALT_VALUE VARCHAR(31),
                   UM_REQUIRE_CHANGE BOOLEAN DEFAULT FALSE,
                   UM_CHANGED_TIME TIMESTAMP NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID),
                   UNIQUE(UM_USER_NAME, UM_TENANT_ID)
      );


      DROP TABLE IF EXISTS UM_SYSTEM_USER  CASCADE;
      DROP SEQUENCE IF EXISTS UM_SYSTEM_USER_PK_SEQ;
      CREATE SEQUENCE UM_SYSTEM_USER_PK_SEQ;
      CREATE TABLE UM_SYSTEM_USER (
                   UM_ID INTEGER DEFAULT NEXTVAL('UM_SYSTEM_USER_PK_SEQ'),
                   UM_USER_NAME VARCHAR(255) NOT NULL,
                   UM_USER_PASSWORD VARCHAR(255) NOT NULL,
                   UM_SALT_VALUE VARCHAR(31),
                   UM_REQUIRE_CHANGE BOOLEAN DEFAULT FALSE,
                   UM_CHANGED_TIME TIMESTAMP NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID),
                   UNIQUE(UM_USER_NAME, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_ROLE CASCADE;
      DROP SEQUENCE IF EXISTS UM_ROLE_PK_SEQ;
      CREATE SEQUENCE UM_ROLE_PK_SEQ;
      CREATE TABLE UM_ROLE (
                   UM_ID INTEGER DEFAULT NEXTVAL('UM_ROLE_PK_SEQ'),
                   UM_ROLE_NAME VARCHAR(255) NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
      		UM_SHARED_ROLE BOOLEAN DEFAULT FALSE,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID),
                   UNIQUE(UM_ROLE_NAME, UM_TENANT_ID)
      );


      DROP TABLE IF EXISTS UM_MODULE CASCADE;
      DROP SEQUENCE IF EXISTS UM_MODULE_PK_SEQ;
      CREATE SEQUENCE UM_MODULE_PK_SEQ;
      CREATE TABLE UM_MODULE(
      	UM_ID INTEGER  DEFAULT NEXTVAL('UM_MODULE_PK_SEQ'),
      	UM_MODULE_NAME VARCHAR(100),
      	UNIQUE(UM_MODULE_NAME),
      	PRIMARY KEY(UM_ID)
      );

      DROP TABLE IF EXISTS UM_MODULE_ACTIONS CASCADE;
      CREATE TABLE UM_MODULE_ACTIONS(
      	UM_ACTION VARCHAR(255) NOT NULL,
      	UM_MODULE_ID INTEGER NOT NULL,
      	PRIMARY KEY(UM_ACTION, UM_MODULE_ID),
      	FOREIGN KEY (UM_MODULE_ID) REFERENCES UM_MODULE(UM_ID) ON DELETE CASCADE
      );


      DROP TABLE IF EXISTS UM_PERMISSION CASCADE;
      DROP SEQUENCE IF EXISTS UM_PERMISSION_PK_SEQ;
      CREATE SEQUENCE UM_PERMISSION_PK_SEQ;
      CREATE TABLE UM_PERMISSION (
                   UM_ID INTEGER DEFAULT NEXTVAL('UM_PERMISSION_PK_SEQ'),
                   UM_RESOURCE_ID VARCHAR(255) NOT NULL,
                   UM_ACTION VARCHAR(255) NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
      	     UM_MODULE_ID INTEGER DEFAULT 0,
      	         	 UNIQUE(UM_RESOURCE_ID,UM_ACTION, UM_TENANT_ID),
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      CREATE INDEX INDEX_UM_PERMISSION_UM_RESOURCE_ID_UM_ACTION
                          ON UM_PERMISSION (UM_RESOURCE_ID, UM_ACTION, UM_TENANT_ID);


      DROP TABLE IF EXISTS UM_ROLE_PERMISSION;
      DROP SEQUENCE IF EXISTS UM_ROLE_PERMISSION_PK_SEQ;
      CREATE SEQUENCE UM_ROLE_PERMISSION_PK_SEQ;
      CREATE TABLE UM_ROLE_PERMISSION (
                   UM_ID INTEGER DEFAULT NEXTVAL('UM_ROLE_PERMISSION_PK_SEQ'),
                   UM_PERMISSION_ID INTEGER NOT NULL,
                   UM_ROLE_NAME VARCHAR(255) NOT NULL,
                   UM_IS_ALLOWED SMALLINT NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
      	     UM_DOMAIN_ID INTEGER,
                   FOREIGN KEY (UM_PERMISSION_ID, UM_TENANT_ID) REFERENCES UM_PERMISSION(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
      	     FOREIGN KEY (UM_DOMAIN_ID, UM_TENANT_ID) REFERENCES UM_DOMAIN(UM_DOMAIN_ID, UM_TENANT_ID) ON DELETE CASCADE,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_USER_PERMISSION;
      DROP SEQUENCE IF EXISTS UM_USER_PERMISSION_PK_SEQ;
      CREATE SEQUENCE UM_USER_PERMISSION_PK_SEQ;
      CREATE TABLE UM_USER_PERMISSION (
                   UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_PERMISSION_PK_SEQ'),
                   UM_PERMISSION_ID INTEGER NOT NULL,
                   UM_USER_NAME VARCHAR(255) NOT NULL,
                   UM_IS_ALLOWED SMALLINT NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   FOREIGN KEY (UM_PERMISSION_ID, UM_TENANT_ID) REFERENCES UM_PERMISSION(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_USER_ROLE;
      DROP SEQUENCE IF EXISTS UM_USER_ROLE_PK_SEQ;
      CREATE SEQUENCE UM_USER_ROLE_PK_SEQ;
      CREATE TABLE UM_USER_ROLE (
                   UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_ROLE_PK_SEQ'),
                   UM_ROLE_ID INTEGER NOT NULL,
                   UM_USER_ID INTEGER NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   UNIQUE (UM_USER_ID, UM_ROLE_ID, UM_TENANT_ID),
                   FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_ROLE(UM_ID, UM_TENANT_ID),
                   FOREIGN KEY (UM_USER_ID, UM_TENANT_ID) REFERENCES UM_USER(UM_ID, UM_TENANT_ID),
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_SHARED_USER_ROLE;
      CREATE TABLE UM_SHARED_USER_ROLE(
          UM_ROLE_ID INTEGER NOT NULL,
          UM_USER_ID INTEGER NOT NULL,
          UM_USER_TENANT_ID INTEGER NOT NULL,
          UM_ROLE_TENANT_ID INTEGER NOT NULL,
          UNIQUE(UM_USER_ID,UM_ROLE_ID,UM_USER_TENANT_ID, UM_ROLE_TENANT_ID),
          FOREIGN KEY(UM_ROLE_ID,UM_ROLE_TENANT_ID) REFERENCES UM_ROLE(UM_ID,UM_TENANT_ID) ON DELETE CASCADE ,
          FOREIGN KEY(UM_USER_ID,UM_USER_TENANT_ID) REFERENCES UM_USER(UM_ID,UM_TENANT_ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS UM_ACCOUNT_MAPPING;
      DROP SEQUENCE IF EXISTS UM_ACCOUNT_MAPPING_SEQ;
      CREATE SEQUENCE UM_ACCOUNT_MAPPING_SEQ;
      CREATE TABLE UM_ACCOUNT_MAPPING(
      	UM_ID INTEGER DEFAULT NEXTVAL('UM_ACCOUNT_MAPPING_SEQ'),
      	UM_USER_NAME VARCHAR(255) NOT NULL,
      	UM_TENANT_ID INTEGER NOT NULL,
      	UM_USER_STORE_DOMAIN VARCHAR(100),
      	UM_ACC_LINK_ID INTEGER NOT NULL,
      	UNIQUE(UM_USER_NAME, UM_TENANT_ID, UM_USER_STORE_DOMAIN, UM_ACC_LINK_ID),
      	FOREIGN KEY (UM_TENANT_ID) REFERENCES UM_TENANT(UM_ID) ON DELETE CASCADE,
      	PRIMARY KEY (UM_ID)
      );

      DROP TABLE IF EXISTS UM_USER_ATTRIBUTE;
      DROP SEQUENCE IF EXISTS UM_USER_ATTRIBUTE_PK_SEQ;
      CREATE SEQUENCE UM_USER_ATTRIBUTE_PK_SEQ;
      CREATE TABLE UM_USER_ATTRIBUTE (
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_ATTRIBUTE_PK_SEQ'),
                  UM_ATTR_NAME VARCHAR(255) NOT NULL,
                  UM_ATTR_VALUE VARCHAR(1024),
                  UM_PROFILE_ID VARCHAR(255),
                  UM_USER_ID INTEGER,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  FOREIGN KEY (UM_USER_ID, UM_TENANT_ID) REFERENCES UM_USER(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      CREATE INDEX UM_USER_ID_INDEX ON UM_USER_ATTRIBUTE(UM_USER_ID);

      DROP TABLE IF EXISTS UM_DIALECT CASCADE;
      DROP SEQUENCE IF EXISTS UM_DIALECT_PK_SEQ;
      CREATE SEQUENCE UM_DIALECT_PK_SEQ;
      CREATE TABLE UM_DIALECT(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_DIALECT_PK_SEQ'),
                  UM_DIALECT_URI VARCHAR(255) NOT NULL,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  UNIQUE(UM_DIALECT_URI, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_CLAIM;
      DROP SEQUENCE IF EXISTS UM_CLAIM_PK_SEQ;
      CREATE SEQUENCE UM_CLAIM_PK_SEQ;
      CREATE TABLE UM_CLAIM(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_CLAIM_PK_SEQ'),
                  UM_DIALECT_ID INTEGER NOT NULL,
                  UM_CLAIM_URI VARCHAR(255) NOT NULL,
                  UM_DISPLAY_TAG VARCHAR(255),
                  UM_DESCRIPTION VARCHAR(255),
                  UM_MAPPED_ATTRIBUTE_DOMAIN VARCHAR(255),
                  UM_MAPPED_ATTRIBUTE VARCHAR(255),
                  UM_REG_EX VARCHAR(255),
                  UM_SUPPORTED SMALLINT,
                  UM_REQUIRED SMALLINT,
                  UM_DISPLAY_ORDER INTEGER,
      	    UM_CHECKED_ATTRIBUTE SMALLINT,
      	    UM_READ_ONLY SMALLINT,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  UNIQUE(UM_DIALECT_ID, UM_CLAIM_URI, UM_TENANT_ID),
                  FOREIGN KEY(UM_DIALECT_ID, UM_TENANT_ID) REFERENCES UM_DIALECT(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_PROFILE_CONFIG;
      DROP SEQUENCE IF EXISTS UM_PROFILE_CONFIG_PK_SEQ;
      CREATE SEQUENCE UM_PROFILE_CONFIG_PK_SEQ;
      CREATE TABLE UM_PROFILE_CONFIG(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_PROFILE_CONFIG_PK_SEQ'),
                  UM_DIALECT_ID INTEGER NOT NULL,
                  UM_PROFILE_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  FOREIGN KEY(UM_DIALECT_ID, UM_TENANT_ID) REFERENCES UM_DIALECT(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_CLAIM_BEHAVIOR;
      DROP SEQUENCE IF EXISTS UM_CLAIM_BEHAVIOR_PK_SEQ;
      CREATE SEQUENCE UM_CLAIM_BEHAVIOR_PK_SEQ;
      CREATE TABLE UM_CLAIM_BEHAVIOR(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_CLAIM_BEHAVIOR_PK_SEQ'),
                  UM_PROFILE_ID INTEGER,
                  UM_CLAIM_ID INTEGER,
                  UM_BEHAVIOUR SMALLINT,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  FOREIGN KEY(UM_PROFILE_ID, UM_TENANT_ID) REFERENCES UM_PROFILE_CONFIG(UM_ID, UM_TENANT_ID),
                  FOREIGN KEY(UM_CLAIM_ID, UM_TENANT_ID) REFERENCES UM_CLAIM(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_HYBRID_ROLE;
      DROP SEQUENCE IF EXISTS UM_HYBRID_ROLE_PK_SEQ;
      CREATE SEQUENCE UM_HYBRID_ROLE_PK_SEQ;
      CREATE TABLE UM_HYBRID_ROLE(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_HYBRID_ROLE_PK_SEQ'),
                  UM_ROLE_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_HYBRID_USER_ROLE;
      DROP SEQUENCE IF EXISTS UM_HYBRID_USER_ROLE_PK_SEQ;
      CREATE SEQUENCE UM_HYBRID_USER_ROLE_PK_SEQ;
      CREATE TABLE UM_HYBRID_USER_ROLE(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_HYBRID_USER_ROLE_PK_SEQ'),
                  UM_USER_NAME VARCHAR(255),
                  UM_ROLE_ID INTEGER NOT NULL,
                  UM_TENANT_ID INTEGER DEFAULT 0,
      	    UM_DOMAIN_ID INTEGER,
                  UNIQUE (UM_USER_NAME, UM_ROLE_ID, UM_TENANT_ID, UM_DOMAIN_ID),
                  FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_HYBRID_ROLE(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
      	    FOREIGN KEY (UM_DOMAIN_ID, UM_TENANT_ID) REFERENCES UM_DOMAIN(UM_DOMAIN_ID, UM_TENANT_ID) ON DELETE CASCADE,
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS UM_SYSTEM_ROLE;
      DROP SEQUENCE IF EXISTS UM_SYSTEM_ROLE_PK_SEQ;
      CREATE SEQUENCE UM_SYSTEM_ROLE_PK_SEQ;
      CREATE TABLE UM_SYSTEM_ROLE(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_SYSTEM_ROLE_PK_SEQ'),
                  UM_ROLE_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      CREATE INDEX SYSTEM_ROLE_IND_BY_RN_TI ON UM_SYSTEM_ROLE(UM_ROLE_NAME, UM_TENANT_ID);

      DROP TABLE IF EXISTS UM_SYSTEM_USER_ROLE;
      DROP SEQUENCE IF EXISTS UM_SYSTEM_USER_ROLE_PK_SEQ;
      CREATE SEQUENCE UM_SYSTEM_USER_ROLE_PK_SEQ;
      CREATE TABLE UM_SYSTEM_USER_ROLE(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_SYSTEM_USER_ROLE_PK_SEQ'),
                  UM_USER_NAME VARCHAR(255),
                  UM_ROLE_ID INTEGER NOT NULL,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  UNIQUE (UM_USER_NAME, UM_ROLE_ID, UM_TENANT_ID),
                  FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_SYSTEM_ROLE(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );



      DROP TABLE IF EXISTS UM_HYBRID_REMEMBER_ME;
      DROP SEQUENCE IF EXISTS UM_HYBRID_REMEMBER_ME_PK_SEQ;
      CREATE SEQUENCE UM_HYBRID_REMEMBER_ME_PK_SEQ;
      CREATE TABLE UM_HYBRID_REMEMBER_ME(
                  UM_ID INTEGER DEFAULT NEXTVAL('UM_HYBRID_REMEMBER_ME_PK_SEQ'),
                  UM_USER_NAME VARCHAR(255) NOT NULL,
      			UM_COOKIE_VALUE VARCHAR(1024),
      			UM_CREATED_TIME TIMESTAMP,
                  UM_TENANT_ID INTEGER DEFAULT 0,
      			PRIMARY KEY (UM_ID, UM_TENANT_ID)
      );

      DROP TABLE IF EXISTS IDN_BASE_TABLE;
      CREATE TABLE IDN_BASE_TABLE (
                  PRODUCT_NAME VARCHAR(20),
                  PRIMARY KEY (PRODUCT_NAME)
      );

      INSERT INTO IDN_BASE_TABLE values ('WSO2 Identity Server');

      DROP TABLE IF EXISTS IDN_OAUTH_CONSUMER_APPS;
      DROP SEQUENCE IF EXISTS IDN_OAUTH_CONSUMER_APPS_PK_SEQ;
      CREATE SEQUENCE IDN_OAUTH_CONSUMER_APPS_PK_SEQ;
      CREATE TABLE IDN_OAUTH_CONSUMER_APPS (
                  ID INTEGER DEFAULT NEXTVAL('IDN_OAUTH_CONSUMER_APPS_PK_SEQ'),
                  CONSUMER_KEY VARCHAR(255),
                  CONSUMER_SECRET VARCHAR(2048),
                  USERNAME VARCHAR(255),
                  TENANT_ID INTEGER DEFAULT 0,
                  USER_DOMAIN VARCHAR(50),
                  APP_NAME VARCHAR(255),
                  OAUTH_VERSION VARCHAR(128),
                  CALLBACK_URL VARCHAR(1024),
                  GRANT_TYPES VARCHAR (1024),
                  PKCE_MANDATORY CHAR(1) DEFAULT '0',
                  PKCE_SUPPORT_PLAIN CHAR(1) DEFAULT '0',
                  APP_STATE VARCHAR (25) DEFAULT 'ACTIVE',
                  USER_ACCESS_TOKEN_EXPIRE_TIME BIGINT DEFAULT 3600,
                  APP_ACCESS_TOKEN_EXPIRE_TIME BIGINT DEFAULT 3600,
                  REFRESH_TOKEN_EXPIRE_TIME BIGINT DEFAULT 84600,
                  ID_TOKEN_EXPIRE_TIME BIGINT DEFAULT 3600,
                  CONSTRAINT CONSUMER_KEY_CONSTRAINT UNIQUE (CONSUMER_KEY),
                  PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS IDN_OAUTH2_SCOPE_VALIDATORS;
      CREATE TABLE IDN_OAUTH2_SCOPE_VALIDATORS (
      	APP_ID INTEGER NOT NULL,
      	SCOPE_VALIDATOR VARCHAR (128) NOT NULL,
      	PRIMARY KEY (APP_ID,SCOPE_VALIDATOR),
      	FOREIGN KEY (APP_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_OAUTH1A_REQUEST_TOKEN;
      CREATE TABLE IDN_OAUTH1A_REQUEST_TOKEN (
                  REQUEST_TOKEN VARCHAR(512),
                  REQUEST_TOKEN_SECRET VARCHAR(512),
                  CONSUMER_KEY_ID INTEGER,
                  CALLBACK_URL VARCHAR(1024),
                  SCOPE VARCHAR(2048),
                  AUTHORIZED VARCHAR(128),
                  OAUTH_VERIFIER VARCHAR(512),
                  AUTHZ_USER VARCHAR(512),
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (REQUEST_TOKEN),
                  FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_OAUTH1A_ACCESS_TOKEN;
      CREATE TABLE IDN_OAUTH1A_ACCESS_TOKEN (
                  ACCESS_TOKEN VARCHAR(512),
                  ACCESS_TOKEN_SECRET VARCHAR(512),
                  CONSUMER_KEY_ID INTEGER,
                  SCOPE VARCHAR(2048),
                  AUTHZ_USER VARCHAR(512),
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (ACCESS_TOKEN),
                  FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_OAUTH2_ACCESS_TOKEN;
      CREATE TABLE IDN_OAUTH2_ACCESS_TOKEN (
                  TOKEN_ID VARCHAR (255),
                  ACCESS_TOKEN VARCHAR(2048),
                  REFRESH_TOKEN VARCHAR(2048),
                  CONSUMER_KEY_ID INTEGER,
                  AUTHZ_USER VARCHAR (100),
                  TENANT_ID INTEGER,
                  USER_DOMAIN VARCHAR(50),
                  USER_TYPE VARCHAR (25),
                  GRANT_TYPE VARCHAR (50),
                  TIME_CREATED TIMESTAMP,
                  REFRESH_TOKEN_TIME_CREATED TIMESTAMP,
                  VALIDITY_PERIOD BIGINT,
                  REFRESH_TOKEN_VALIDITY_PERIOD BIGINT,
                  TOKEN_SCOPE_HASH VARCHAR(32),
                  TOKEN_STATE VARCHAR(25) DEFAULT 'ACTIVE',
                  TOKEN_STATE_ID VARCHAR (128) DEFAULT 'NONE',
                  SUBJECT_IDENTIFIER VARCHAR(255),
                  ACCESS_TOKEN_HASH VARCHAR(512),
                  REFRESH_TOKEN_HASH VARCHAR(512),
                  PRIMARY KEY (TOKEN_ID),
                  FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE,
                  CONSTRAINT CON_APP_KEY UNIQUE (CONSUMER_KEY_ID,AUTHZ_USER,TENANT_ID,USER_DOMAIN,USER_TYPE,TOKEN_SCOPE_HASH,
                                                 TOKEN_STATE,TOKEN_STATE_ID)
      );



      DROP TABLE IF EXISTS IDN_OAUTH2_ACCESS_TOKEN_AUDIT;
      CREATE TABLE IF NOT EXISTS IDN_OAUTH2_ACCESS_TOKEN_AUDIT (
                  TOKEN_ID VARCHAR (255),
                  ACCESS_TOKEN VARCHAR(2048),
                  REFRESH_TOKEN VARCHAR(2048),
                  CONSUMER_KEY_ID INTEGER,
                  AUTHZ_USER VARCHAR (100),
                  TENANT_ID INTEGER,
                  USER_DOMAIN VARCHAR(50),
                  USER_TYPE VARCHAR (25),
                  GRANT_TYPE VARCHAR (50),
                  TIME_CREATED TIMESTAMP NULL,
                  REFRESH_TOKEN_TIME_CREATED TIMESTAMP NULL,
                  VALIDITY_PERIOD BIGINT,
                  REFRESH_TOKEN_VALIDITY_PERIOD BIGINT,
                  TOKEN_SCOPE_HASH VARCHAR(32),
                  TOKEN_STATE VARCHAR(25),
                  TOKEN_STATE_ID VARCHAR (128) ,
                  SUBJECT_IDENTIFIER VARCHAR(255),
                  ACCESS_TOKEN_HASH VARCHAR(512),
                  REFRESH_TOKEN_HASH VARCHAR(512),
                  INVALIDATED_TIME TIMESTAMP NULL
      );

      DROP TABLE IF EXISTS IDN_OAUTH2_AUTHORIZATION_CODE;
      CREATE TABLE IDN_OAUTH2_AUTHORIZATION_CODE (
                  CODE_ID VARCHAR (255),
                  AUTHORIZATION_CODE VARCHAR(2048),
                  CONSUMER_KEY_ID INTEGER,
      	          CALLBACK_URL VARCHAR(1024),
                  SCOPE VARCHAR(2048),
                  AUTHZ_USER VARCHAR (100),
                  TENANT_ID INTEGER,
                  USER_DOMAIN VARCHAR(50),
      	          TIME_CREATED TIMESTAMP,
      	          VALIDITY_PERIOD BIGINT,
                  STATE VARCHAR (25) DEFAULT 'ACTIVE',
                  TOKEN_ID VARCHAR(255),
                  SUBJECT_IDENTIFIER VARCHAR(255),
                  PKCE_CODE_CHALLENGE VARCHAR (255),
                  PKCE_CODE_CHALLENGE_METHOD VARCHAR(128),
                  AUTHORIZATION_CODE_HASH VARCHAR(512),
                  PRIMARY KEY (CODE_ID),
                  FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
      );



      DROP TABLE IF EXISTS IDN_OAUTH2_ACCESS_TOKEN_SCOPE;
      CREATE TABLE IDN_OAUTH2_ACCESS_TOKEN_SCOPE (
                  TOKEN_ID VARCHAR (255),
                  TOKEN_SCOPE VARCHAR (60),
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (TOKEN_ID, TOKEN_SCOPE),
                  FOREIGN KEY (TOKEN_ID) REFERENCES IDN_OAUTH2_ACCESS_TOKEN(TOKEN_ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDN_OAUTH2_SCOPE;
      DROP SEQUENCE IF EXISTS IDN_OAUTH2_SCOPE_PK_SEQ;
      CREATE SEQUENCE IDN_OAUTH2_SCOPE_PK_SEQ;
      CREATE TABLE IF NOT EXISTS IDN_OAUTH2_SCOPE (
                  SCOPE_ID INTEGER DEFAULT NEXTVAL('IDN_OAUTH2_SCOPE_PK_SEQ'),
                  NAME VARCHAR(255) NOT NULL,
                  DISPLAY_NAME VARCHAR(255) NOT NULL,
                  DESCRIPTION VARCHAR(512),
                  TENANT_ID INTEGER NOT NULL DEFAULT -1,
                  PRIMARY KEY (SCOPE_ID)
      );

      DROP TABLE IF EXISTS IDN_OAUTH2_SCOPE_BINDING;
      CREATE TABLE IF NOT EXISTS IDN_OAUTH2_SCOPE_BINDING (
                  SCOPE_ID INTEGER NOT NULL,
                  SCOPE_BINDING VARCHAR(255),
                  FOREIGN KEY (SCOPE_ID) REFERENCES IDN_OAUTH2_SCOPE(SCOPE_ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_OAUTH2_RESOURCE_SCOPE;
      CREATE TABLE IF NOT EXISTS IDN_OAUTH2_RESOURCE_SCOPE (
                  RESOURCE_PATH VARCHAR(255) NOT NULL,
                  SCOPE_ID INTEGER NOT NULL,
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (RESOURCE_PATH),
                  FOREIGN KEY (SCOPE_ID) REFERENCES IDN_OAUTH2_SCOPE (SCOPE_ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_SCIM_GROUP;
      DROP SEQUENCE IF EXISTS IDN_SCIM_GROUP_PK_SEQ;
      CREATE SEQUENCE IDN_SCIM_GROUP_PK_SEQ;
      CREATE TABLE IDN_SCIM_GROUP (
      			ID INTEGER DEFAULT NEXTVAL('IDN_SCIM_GROUP_PK_SEQ'),
      			TENANT_ID INTEGER NOT NULL,
      			ROLE_NAME VARCHAR(255) NOT NULL,
                  ATTR_NAME VARCHAR(1024) NOT NULL,
      			ATTR_VALUE VARCHAR(1024),
                  PRIMARY KEY (ID)
      );


      DROP TABLE IF EXISTS IDN_OPENID_REMEMBER_ME;
      CREATE TABLE IDN_OPENID_REMEMBER_ME (
                  USER_NAME VARCHAR(255) NOT NULL,
                  TENANT_ID INTEGER DEFAULT 0,
                  COOKIE_VALUE VARCHAR(1024),
                  CREATED_TIME TIMESTAMP,
                  PRIMARY KEY (USER_NAME, TENANT_ID)
      );

      DROP TABLE IF EXISTS IDN_OPENID_USER_RPS;
      CREATE TABLE IDN_OPENID_USER_RPS (
      			USER_NAME VARCHAR(255) NOT NULL,
      			TENANT_ID INTEGER DEFAULT 0,
      			RP_URL VARCHAR(255) NOT NULL,
      			TRUSTED_ALWAYS VARCHAR(128) DEFAULT 'FALSE',
      			LAST_VISIT DATE NOT NULL,
      			VISIT_COUNT INTEGER DEFAULT 0,
      			DEFAULT_PROFILE_NAME VARCHAR(255) DEFAULT 'DEFAULT',
      			PRIMARY KEY (USER_NAME, TENANT_ID, RP_URL)
      );

      DROP TABLE IF EXISTS IDN_OPENID_ASSOCIATIONS;
      CREATE TABLE IDN_OPENID_ASSOCIATIONS (
                  HANDLE VARCHAR(255) NOT NULL,
                  ASSOC_TYPE VARCHAR(255) NOT NULL,
                  EXPIRE_IN TIMESTAMP NOT NULL,
                  MAC_KEY VARCHAR(255) NOT NULL,
                  ASSOC_STORE VARCHAR(128) DEFAULT 'SHARED',
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (HANDLE)
      );

      DROP TABLE IF EXISTS IDN_STS_STORE;
      DROP SEQUENCE IF EXISTS IDN_STS_STORE_PK_SEQ;
      CREATE SEQUENCE IDN_STS_STORE_PK_SEQ;
      CREATE TABLE IDN_STS_STORE (
                  ID INTEGER DEFAULT NEXTVAL('IDN_STS_STORE_PK_SEQ'),
                  TOKEN_ID VARCHAR(255) NOT NULL,
                  TOKEN_CONTENT BYTEA NOT NULL,
                  CREATE_DATE TIMESTAMP NOT NULL,
                  EXPIRE_DATE TIMESTAMP NOT NULL,
                  STATE INTEGER DEFAULT 0,
                  PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS IDN_IDENTITY_USER_DATA;
      CREATE TABLE IDN_IDENTITY_USER_DATA (
                  TENANT_ID INTEGER DEFAULT -1234,
                  USER_NAME VARCHAR(255) NOT NULL,
                  DATA_KEY VARCHAR(255) NOT NULL,
                  DATA_VALUE VARCHAR(2048),
                  PRIMARY KEY (TENANT_ID, USER_NAME, DATA_KEY)
      );

      DROP TABLE IF EXISTS IDN_IDENTITY_META_DATA;
      CREATE TABLE IDN_IDENTITY_META_DATA (
                  USER_NAME VARCHAR(255) NOT NULL,
                  TENANT_ID INTEGER DEFAULT -1234,
                  METADATA_TYPE VARCHAR(255) NOT NULL,
                  METADATA VARCHAR(255) NOT NULL,
                  VALID VARCHAR(255) NOT NULL,
                  PRIMARY KEY (TENANT_ID, USER_NAME, METADATA_TYPE,METADATA)
      );

      DROP TABLE IF EXISTS IDN_THRIFT_SESSION;
      CREATE TABLE IDN_THRIFT_SESSION (
                  SESSION_ID VARCHAR(255) NOT NULL,
                  USER_NAME VARCHAR(255) NOT NULL,
                  CREATED_TIME VARCHAR(255) NOT NULL,
                  LAST_MODIFIED_TIME VARCHAR(255) NOT NULL,
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (SESSION_ID)
      );

      DROP TABLE IF EXISTS IDN_AUTH_SESSION_STORE;
      CREATE TABLE IDN_AUTH_SESSION_STORE (
                  SESSION_ID VARCHAR(100) NOT NULL,
                  SESSION_TYPE VARCHAR(100) NOT NULL,
                  OPERATION VARCHAR(10) NOT NULL,
                  SESSION_OBJECT BYTEA,
                  TIME_CREATED BIGINT,
                  TENANT_ID INTEGER DEFAULT -1,
                  EXPIRY_TIME BIGINT,
                  PRIMARY KEY (SESSION_ID, SESSION_TYPE, TIME_CREATED, OPERATION)
      );




      DROP TABLE IF EXISTS IDN_AUTH_TEMP_SESSION_STORE;
      CREATE TABLE IDN_AUTH_TEMP_SESSION_STORE (
                  SESSION_ID VARCHAR(100) NOT NULL,
                  SESSION_TYPE VARCHAR(100) NOT NULL,
                  OPERATION VARCHAR(10) NOT NULL,
                  SESSION_OBJECT BYTEA,
                  TIME_CREATED BIGINT,
                  TENANT_ID INTEGER DEFAULT -1,
                  EXPIRY_TIME BIGINT,
                  PRIMARY KEY (SESSION_ID, SESSION_TYPE, TIME_CREATED, OPERATION)
      );




      DROP TABLE IF EXISTS SP_APP;
      DROP SEQUENCE IF EXISTS SP_APP_SEQ;
      CREATE SEQUENCE SP_APP_SEQ;
      CREATE TABLE SP_APP (
                  ID INTEGER DEFAULT NEXTVAL('SP_APP_SEQ'),
                  TENANT_ID INTEGER NOT NULL,
                  APP_NAME VARCHAR (255) NOT NULL ,
                  USER_STORE VARCHAR (255) NOT NULL,
                  USERNAME VARCHAR (255) NOT NULL ,
                  DESCRIPTION VARCHAR (1024),
      	    	    ROLE_CLAIM VARCHAR (512),
                  AUTH_TYPE VARCHAR (255) NOT NULL,
                  PROVISIONING_USERSTORE_DOMAIN VARCHAR (512),
                  IS_LOCAL_CLAIM_DIALECT CHAR(1) DEFAULT '1',
                  IS_SEND_LOCAL_SUBJECT_ID CHAR(1) DEFAULT '0',
                  IS_SEND_AUTH_LIST_OF_IDPS CHAR(1) DEFAULT '0',
                  IS_USE_TENANT_DOMAIN_SUBJECT CHAR(1) DEFAULT '1',
                  IS_USE_USER_DOMAIN_SUBJECT CHAR(1) DEFAULT '1',
                  ENABLE_AUTHORIZATION CHAR(1) DEFAULT '0',
                  SUBJECT_CLAIM_URI VARCHAR (512),
                  IS_SAAS_APP CHAR(1) DEFAULT '0',
                  IS_DUMB_MODE CHAR(1) DEFAULT '0',
                  PRIMARY KEY (ID));

      ALTER TABLE SP_APP ADD CONSTRAINT APPLICATION_NAME_CONSTRAINT UNIQUE(APP_NAME, TENANT_ID);

      DROP TABLE IF EXISTS SP_METADATA;
      DROP SEQUENCE IF EXISTS SP_METADATA_SEQ;
      CREATE SEQUENCE SP_METADATA_SEQ;
      CREATE TABLE SP_METADATA (
                  ID INTEGER DEFAULT NEXTVAL('SP_METADATA_SEQ'),
                  SP_ID INTEGER,
                  NAME VARCHAR(255) NOT NULL,
                  VALUE VARCHAR(255) NOT NULL,
                  DISPLAY_NAME VARCHAR(255),
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (ID),
                  CONSTRAINT SP_METADATA_CONSTRAINT UNIQUE (SP_ID, NAME),
                  FOREIGN KEY (SP_ID) REFERENCES SP_APP(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS SP_INBOUND_AUTH;
      DROP SEQUENCE IF EXISTS SP_INBOUND_AUTH_SEQ;
      CREATE SEQUENCE SP_INBOUND_AUTH_SEQ;
      CREATE TABLE SP_INBOUND_AUTH (
                  ID INTEGER DEFAULT NEXTVAL('SP_INBOUND_AUTH_SEQ'),
                  TENANT_ID INTEGER NOT NULL,
                  INBOUND_AUTH_KEY VARCHAR (255),
                  INBOUND_AUTH_TYPE VARCHAR (255) NOT NULL,
                  INBOUND_CONFIG_TYPE VARCHAR (255) NOT NULL,
                  PROP_NAME VARCHAR (255),
                  PROP_VALUE VARCHAR (1024) ,
                  APP_ID INTEGER NOT NULL,
                  PRIMARY KEY (ID));

      ALTER TABLE SP_INBOUND_AUTH ADD CONSTRAINT APPLICATION_ID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_AUTH_STEP;
      DROP SEQUENCE IF EXISTS SP_AUTH_STEP_SEQ;
      CREATE SEQUENCE SP_AUTH_STEP_SEQ;
      CREATE TABLE SP_AUTH_STEP (
                  ID INTEGER DEFAULT NEXTVAL('SP_AUTH_STEP_SEQ'),
                  TENANT_ID INTEGER NOT NULL,
      	     	STEP_ORDER INTEGER DEFAULT 1,
                  APP_ID INTEGER NOT NULL,
                  IS_SUBJECT_STEP CHAR(1) DEFAULT '0',
                  IS_ATTRIBUTE_STEP CHAR(1) DEFAULT '0',
                  PRIMARY KEY (ID));

      ALTER TABLE SP_AUTH_STEP ADD CONSTRAINT APPLICATION_ID_CONSTRAINT_STEP FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_FEDERATED_IDP;
      CREATE TABLE SP_FEDERATED_IDP (
                  ID INTEGER NOT NULL,
                  TENANT_ID INTEGER NOT NULL,
                  AUTHENTICATOR_ID INTEGER NOT NULL,
                  PRIMARY KEY (ID, AUTHENTICATOR_ID));

      ALTER TABLE SP_FEDERATED_IDP ADD CONSTRAINT STEP_ID_CONSTRAINT FOREIGN KEY (ID) REFERENCES SP_AUTH_STEP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_CLAIM_DIALECT;
      DROP SEQUENCE IF EXISTS SP_CLAIM_DIALECT_SEQ;
      CREATE SEQUENCE SP_CLAIM_DIALECT_SEQ;
      CREATE TABLE SP_CLAIM_DIALECT (
      	    	ID INTEGER DEFAULT NEXTVAL('SP_CLAIM_DIALECT_SEQ'),
      	    	TENANT_ID INTEGER NOT NULL,
      	    	SP_DIALECT VARCHAR (512) NOT NULL,
      	   		APP_ID INTEGER NOT NULL,
              PRIMARY KEY (ID));

      ALTER TABLE SP_CLAIM_DIALECT ADD CONSTRAINT DIALECTID_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_CLAIM_MAPPING;
      DROP SEQUENCE IF EXISTS SP_CLAIM_MAPPING_SEQ;
      CREATE SEQUENCE SP_CLAIM_MAPPING_SEQ;
      CREATE TABLE SP_CLAIM_MAPPING (
      	    	ID INTEGER DEFAULT NEXTVAL('SP_CLAIM_MAPPING_SEQ'),
      	    	TENANT_ID INTEGER NOT NULL,
      	    	IDP_CLAIM VARCHAR (512) NOT NULL ,
                  SP_CLAIM VARCHAR (512) NOT NULL ,
      	   		APP_ID INTEGER NOT NULL,
      	    	IS_REQUESTED VARCHAR(128) DEFAULT '0',
      		IS_MANDATORY VARCHAR(128) DEFAULT '0',
      	    	DEFAULT_VALUE VARCHAR(255),
                  PRIMARY KEY (ID));

      ALTER TABLE SP_CLAIM_MAPPING ADD CONSTRAINT CLAIMID_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_ROLE_MAPPING;
      DROP SEQUENCE IF EXISTS SP_ROLE_MAPPING_SEQ;
      CREATE SEQUENCE SP_ROLE_MAPPING_SEQ;
      CREATE TABLE SP_ROLE_MAPPING (
      	    	ID INTEGER DEFAULT NEXTVAL('SP_ROLE_MAPPING_SEQ'),
      	    	TENANT_ID INTEGER NOT NULL,
      	    	IDP_ROLE VARCHAR (255) NOT NULL ,
                  SP_ROLE VARCHAR (255) NOT NULL ,
      	    	APP_ID INTEGER NOT NULL,
                  PRIMARY KEY (ID));

      ALTER TABLE SP_ROLE_MAPPING ADD CONSTRAINT ROLEID_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_REQ_PATH_AUTH;
      DROP SEQUENCE IF EXISTS SP_REQ_PATH_AUTH_SEQ;
      CREATE SEQUENCE SP_REQ_PATH_AUTH_SEQ;
      CREATE TABLE SP_REQ_PATH_AUTHENTICATOR (
      	    	ID INTEGER DEFAULT NEXTVAL('SP_REQ_PATH_AUTH_SEQ'),
      	    	TENANT_ID INTEGER NOT NULL,
      	    	AUTHENTICATOR_NAME VARCHAR (255) NOT NULL ,
      	    	APP_ID INTEGER NOT NULL,
                  PRIMARY KEY (ID));

      ALTER TABLE SP_REQ_PATH_AUTHENTICATOR ADD CONSTRAINT REQ_AUTH_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_PROV_CONNECTOR;
      DROP SEQUENCE IF EXISTS SP_PROV_CONNECTOR_SEQ;
      CREATE SEQUENCE SP_PROV_CONNECTOR_SEQ;
      CREATE TABLE SP_PROVISIONING_CONNECTOR (
      	    	ID INTEGER DEFAULT NEXTVAL('SP_PROV_CONNECTOR_SEQ'),
      	    	TENANT_ID INTEGER NOT NULL,
                  IDP_NAME VARCHAR (255) NOT NULL ,
      	    	CONNECTOR_NAME VARCHAR (255) NOT NULL ,
      	    	APP_ID INTEGER NOT NULL,
      	    	IS_JIT_ENABLED CHAR(1) NOT NULL DEFAULT '0',
      		    BLOCKING CHAR(1) NOT NULL DEFAULT '0',
      		    RULE_ENABLED CHAR(1) NOT NULL DEFAULT '0',
                  PRIMARY KEY (ID));

      ALTER TABLE SP_PROVISIONING_CONNECTOR ADD CONSTRAINT PRO_CONNECTOR_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

      DROP TABLE IF EXISTS SP_AUTH_SCRIPT;
      DROP SEQUENCE IF EXISTS SP_AUTH_SCRIPT_SEQ;
      CREATE SEQUENCE SP_AUTH_SCRIPT_SEQ;
      CREATE TABLE SP_AUTH_SCRIPT (
        ID         INTEGER      NOT NULL DEFAULT NEXTVAL('SP_AUTH_SCRIPT_SEQ'),
        TENANT_ID  INTEGER      NOT NULL,
        APP_ID     INTEGER      NOT NULL,
        TYPE       VARCHAR(255) NOT NULL,
        CONTENT    BYTEA                 DEFAULT NULL,
        IS_ENABLED CHAR(1) NOT NULL DEFAULT '0',
        PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS SP_TEMPLATE;
      DROP SEQUENCE IF EXISTS SP_TEMPLATE_SEQ;
      CREATE SEQUENCE SP_TEMPLATE_SEQ;
      CREATE TABLE SP_TEMPLATE (
        ID         INTEGER NOT NULL DEFAULT NEXTVAL('SP_TEMPLATE_SEQ'),
        TENANT_ID  INTEGER NOT NULL,
        NAME VARCHAR(255) NOT NULL,
        DESCRIPTION VARCHAR(1023),
        CONTENT BYTEA DEFAULT NULL,
        PRIMARY KEY (ID),
        CONSTRAINT SP_TEMPLATE_CONSTRAINT UNIQUE (TENANT_ID, NAME)
      );


      DROP TABLE IF EXISTS SP_DEFAULT_AUTH_SEQ;
      DROP SEQUENCE IF EXISTS SP_DEFAULT_AUTH_SEQ_SEQ;
      CREATE SEQUENCE SP_DEFAULT_AUTH_SEQ_SEQ;
      CREATE TABLE SP_DEFAULT_AUTH_SEQ (
        ID INTEGER NOT NULL DEFAULT NEXTVAL('SP_DEFAULT_AUTH_SEQ_SEQ'),
        NAME VARCHAR(255) NOT NULL,
        DESCRIPTION VARCHAR(1024),
        SEQ_CONTENT BYTEA DEFAULT NULL,
        TENANT_ID INTEGER NOT NULL,
        PRIMARY KEY (ID),
        CONSTRAINT SP_DEFAULT_AUTH_SEQ_CONSTRAINT UNIQUE (TENANT_ID, NAME)
      );

      DROP TABLE IF EXISTS IDN_AUTH_WAIT_STATUS;
      DROP SEQUENCE IF EXISTS IDN_AUTH_WAIT_STATUS_SEQ;
      CREATE SEQUENCE IDN_AUTH_WAIT_STATUS_SEQ;
      CREATE TABLE IDN_AUTH_WAIT_STATUS (
        ID              INTEGER       NOT NULL DEFAULT NEXTVAL('IDN_AUTH_WAIT_STATUS_SEQ'),
        TENANT_ID       INTEGER       NOT NULL,
        LONG_WAIT_KEY   VARCHAR(255)  NOT NULL,
        WAIT_STATUS     CHAR(1) NOT NULL DEFAULT '1',
        TIME_CREATED    TIMESTAMP,
        EXPIRE_TIME     TIMESTAMP,
        PRIMARY KEY (ID),
        CONSTRAINT IDN_AUTH_WAIT_STATUS_KEY UNIQUE (LONG_WAIT_KEY)
      );

      DROP TABLE IF EXISTS IDP;
      DROP SEQUENCE IF EXISTS IDP_SEQ;
      CREATE SEQUENCE IDP_SEQ;
      CREATE TABLE IDP (
      			ID INTEGER DEFAULT NEXTVAL('IDP_SEQ'),
      			TENANT_ID INTEGER,
      			NAME VARCHAR(254) NOT NULL,
      			IS_ENABLED CHAR(1) NOT NULL DEFAULT '1',
      			IS_PRIMARY CHAR(1) NOT NULL DEFAULT '0',
      			HOME_REALM_ID VARCHAR(254),
      			IMAGE BYTEA,
      			CERTIFICATE BYTEA,
      			ALIAS VARCHAR(254),
      			INBOUND_PROV_ENABLED CHAR (1) NOT NULL DEFAULT '0',
      			INBOUND_PROV_USER_STORE_ID VARCHAR(254),
       			USER_CLAIM_URI VARCHAR(254),
       			ROLE_CLAIM_URI VARCHAR(254),
        			DESCRIPTION VARCHAR (1024),
       			DEFAULT_AUTHENTICATOR_NAME VARCHAR(254),
       			DEFAULT_PRO_CONNECTOR_NAME VARCHAR(254),
       			PROVISIONING_ROLE VARCHAR(128),
       			IS_FEDERATION_HUB CHAR(1) NOT NULL DEFAULT '0',
       			IS_LOCAL_CLAIM_DIALECT CHAR(1) NOT NULL DEFAULT '0',
      	                DISPLAY_NAME VARCHAR(255),
      			PRIMARY KEY (ID),
      			UNIQUE (TENANT_ID, NAME));

      DROP TABLE IF EXISTS IDP_ROLE;
      DROP SEQUENCE IF EXISTS IDP_ROLE_SEQ;
      CREATE SEQUENCE IDP_ROLE_SEQ;
      CREATE TABLE IDP_ROLE (
      			ID INTEGER DEFAULT NEXTVAL('IDP_ROLE_SEQ'),
      			IDP_ID INTEGER,
      			TENANT_ID INTEGER,
      			ROLE VARCHAR(254),
      			PRIMARY KEY (ID),
      			UNIQUE (IDP_ID, ROLE),
      			FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_ROLE_MAPPING;
      DROP SEQUENCE IF EXISTS IDP_ROLE_MAPPING_SEQ;
      CREATE SEQUENCE IDP_ROLE_MAPPING_SEQ;
      CREATE TABLE IDP_ROLE_MAPPING (
      			ID INTEGER DEFAULT NEXTVAL('IDP_ROLE_MAPPING_SEQ'),
      			IDP_ROLE_ID INTEGER,
      			TENANT_ID INTEGER,
      			USER_STORE_ID VARCHAR (253),
      			LOCAL_ROLE VARCHAR(253),
      			PRIMARY KEY (ID),
      			UNIQUE (IDP_ROLE_ID, TENANT_ID, USER_STORE_ID, LOCAL_ROLE),
      			FOREIGN KEY (IDP_ROLE_ID) REFERENCES IDP_ROLE(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_CLAIM;
      DROP SEQUENCE IF EXISTS IDP_CLAIM_SEQ;
      CREATE SEQUENCE IDP_CLAIM_SEQ;
      CREATE TABLE IDP_CLAIM (
      			ID INTEGER DEFAULT NEXTVAL('IDP_CLAIM_SEQ'),
      			IDP_ID INTEGER,
      			TENANT_ID INTEGER,
      			CLAIM VARCHAR(254),
      			PRIMARY KEY (ID),
      			UNIQUE (IDP_ID, CLAIM),
      			FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_CLAIM_MAPPING;
      DROP SEQUENCE IF EXISTS IDP_CLAIM_MAPPING_SEQ;
      CREATE SEQUENCE IDP_CLAIM_MAPPING_SEQ;
      CREATE TABLE IDP_CLAIM_MAPPING (
      			ID INTEGER DEFAULT NEXTVAL('IDP_CLAIM_MAPPING_SEQ'),
      			IDP_CLAIM_ID INTEGER,
      			TENANT_ID INTEGER,
      			LOCAL_CLAIM VARCHAR(253),
      		    DEFAULT_VALUE VARCHAR(255),
      	    	IS_REQUESTED VARCHAR(128) DEFAULT '0',
      			PRIMARY KEY (ID),
      			UNIQUE (IDP_CLAIM_ID, TENANT_ID, LOCAL_CLAIM),
      			FOREIGN KEY (IDP_CLAIM_ID) REFERENCES IDP_CLAIM(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_AUTHENTICATOR;
      DROP SEQUENCE IF EXISTS IDP_AUTHENTICATOR_SEQ;
      CREATE SEQUENCE IDP_AUTHENTICATOR_SEQ;
      CREATE TABLE IDP_AUTHENTICATOR (
                  ID INTEGER DEFAULT NEXTVAL('IDP_AUTHENTICATOR_SEQ'),
                  TENANT_ID INTEGER,
                  IDP_ID INTEGER,
                  NAME VARCHAR(255) NOT NULL,
                  IS_ENABLED CHAR (1) DEFAULT '1',
                  DISPLAY_NAME VARCHAR(255),
                  PRIMARY KEY (ID),
                  UNIQUE (TENANT_ID, IDP_ID, NAME),
                  FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_METADATA;
      DROP SEQUENCE IF EXISTS IDP_METADATA_SEQ;
      CREATE SEQUENCE IDP_METADATA_SEQ;
      CREATE TABLE IDP_METADATA (
                  ID INTEGER DEFAULT NEXTVAL('IDP_METADATA_SEQ'),
                  IDP_ID INTEGER,
                  NAME VARCHAR(255) NOT NULL,
                  VALUE VARCHAR(255) NOT NULL,
                  DISPLAY_NAME VARCHAR(255),
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (ID),
                  CONSTRAINT IDP_METADATA_CONSTRAINT UNIQUE (IDP_ID, NAME),
                  FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_AUTHENTICATOR_PROP;
      DROP SEQUENCE IF EXISTS IDP_AUTHENTICATOR_PROP_SEQ;
      CREATE SEQUENCE IDP_AUTHENTICATOR_PROP_SEQ;
      CREATE TABLE IDP_AUTHENTICATOR_PROPERTY (
                  ID INTEGER DEFAULT NEXTVAL('IDP_AUTHENTICATOR_PROP_SEQ'),
                  TENANT_ID INTEGER,
                  AUTHENTICATOR_ID INTEGER,
                  PROPERTY_KEY VARCHAR(255) NOT NULL,
                  PROPERTY_VALUE VARCHAR(2047),
                  IS_SECRET CHAR (1) DEFAULT '0',
                  PRIMARY KEY (ID),
                  UNIQUE (TENANT_ID, AUTHENTICATOR_ID, PROPERTY_KEY),
                  FOREIGN KEY (AUTHENTICATOR_ID) REFERENCES IDP_AUTHENTICATOR(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_PROV_CONFIG;
      DROP SEQUENCE IF EXISTS IDP_PROV_CONFIG_SEQ;
      CREATE SEQUENCE IDP_PROV_CONFIG_SEQ;
      CREATE TABLE IDP_PROVISIONING_CONFIG (
                  ID INTEGER DEFAULT NEXTVAL('IDP_PROV_CONFIG_SEQ'),
                  TENANT_ID INTEGER,
                  IDP_ID INTEGER,
                  PROVISIONING_CONNECTOR_TYPE VARCHAR(255) NOT NULL,
                  IS_ENABLED CHAR (1) DEFAULT '0',
                  IS_BLOCKING CHAR (1) DEFAULT '0',
                  IS_RULES_ENABLED CHAR (1) DEFAULT '0',
                  PRIMARY KEY (ID),
                  UNIQUE (TENANT_ID, IDP_ID, PROVISIONING_CONNECTOR_TYPE),
                  FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_PROV_CONFIG_PROP;
      DROP SEQUENCE IF EXISTS IDP_PROV_CONFIG_PROP_SEQ;
      CREATE SEQUENCE IDP_PROV_CONFIG_PROP_SEQ;
      CREATE TABLE IDP_PROV_CONFIG_PROPERTY (
                  ID INTEGER DEFAULT NEXTVAL('IDP_PROV_CONFIG_PROP_SEQ'),
                  TENANT_ID INTEGER,
                  PROVISIONING_CONFIG_ID INTEGER,
                  PROPERTY_KEY VARCHAR(255) NOT NULL,
                  PROPERTY_VALUE VARCHAR(2048),
                  PROPERTY_BLOB_VALUE BYTEA,
                  PROPERTY_TYPE CHAR(32) NOT NULL,
                  IS_SECRET CHAR (1) DEFAULT '0',
                  PRIMARY KEY (ID),
                  UNIQUE (TENANT_ID, PROVISIONING_CONFIG_ID, PROPERTY_KEY),
                  FOREIGN KEY (PROVISIONING_CONFIG_ID) REFERENCES IDP_PROVISIONING_CONFIG(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_PROV_ENTITY;
      DROP SEQUENCE IF EXISTS IDP_PROV_ENTITY_SEQ;
      CREATE SEQUENCE IDP_PROV_ENTITY_SEQ;
      CREATE TABLE IDP_PROVISIONING_ENTITY (
                  ID INTEGER DEFAULT NEXTVAL('IDP_PROV_ENTITY_SEQ'),
                  PROVISIONING_CONFIG_ID INTEGER,
                  ENTITY_TYPE VARCHAR(255) NOT NULL,
                  ENTITY_LOCAL_USERSTORE VARCHAR(255) NOT NULL,
                  ENTITY_NAME VARCHAR(255) NOT NULL,
                  ENTITY_VALUE VARCHAR(255),
                  TENANT_ID INTEGER,
                  ENTITY_LOCAL_ID VARCHAR(255),
                  PRIMARY KEY (ID),
                  UNIQUE (ENTITY_TYPE, TENANT_ID, ENTITY_LOCAL_USERSTORE, ENTITY_NAME, PROVISIONING_CONFIG_ID),
                  UNIQUE (PROVISIONING_CONFIG_ID, ENTITY_TYPE, ENTITY_VALUE),
                  FOREIGN KEY (PROVISIONING_CONFIG_ID) REFERENCES IDP_PROVISIONING_CONFIG(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDP_LOCAL_CLAIM;
      DROP SEQUENCE IF EXISTS IDP_LOCAL_CLAIM_SEQ;
      CREATE SEQUENCE IDP_LOCAL_CLAIM_SEQ;
      CREATE TABLE IF NOT EXISTS IDP_LOCAL_CLAIM(
                  ID INTEGER DEFAULT NEXTVAL('IDP_LOCAL_CLAIM_SEQ'),
                  TENANT_ID INTEGER,
                  IDP_ID INTEGER,
                  CLAIM_URI VARCHAR(255) NOT NULL,
                  DEFAULT_VALUE VARCHAR(255),
      	        IS_REQUESTED VARCHAR(128) DEFAULT '0',
                  PRIMARY KEY (ID),
                  UNIQUE (TENANT_ID, IDP_ID, CLAIM_URI),
                  FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

      DROP TABLE IF EXISTS IDN_ASSOCIATED_ID;
      DROP SEQUENCE IF EXISTS IDN_ASSOCIATED_ID_SEQ;
      CREATE SEQUENCE IDN_ASSOCIATED_ID_SEQ;
      CREATE TABLE IDN_ASSOCIATED_ID (
                  ID INTEGER DEFAULT NEXTVAL('IDN_ASSOCIATED_ID_SEQ'),
      	    IDP_USER_ID VARCHAR(255) NOT NULL,
                  TENANT_ID INTEGER DEFAULT -1234,
      	    IDP_ID INTEGER NOT NULL,
                  DOMAIN_NAME VARCHAR(255) NOT NULL,
       	    USER_NAME VARCHAR(255) NOT NULL,
      	    PRIMARY KEY (ID),
                  UNIQUE(IDP_USER_ID, TENANT_ID, IDP_ID),
                  FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_USER_ACCOUNT_ASSOCIATION;
      CREATE TABLE IDN_USER_ACCOUNT_ASSOCIATION (
                  ASSOCIATION_KEY VARCHAR(255) NOT NULL,
                  TENANT_ID INTEGER,
                  DOMAIN_NAME VARCHAR(255) NOT NULL,
                  USER_NAME VARCHAR(255) NOT NULL,
                  PRIMARY KEY (TENANT_ID, DOMAIN_NAME, USER_NAME));

      DROP TABLE IF EXISTS FIDO_DEVICE_STORE;
      CREATE TABLE FIDO_DEVICE_STORE (
              TENANT_ID INTEGER,
              DOMAIN_NAME VARCHAR(255) NOT NULL,
              USER_NAME VARCHAR(45) NOT NULL,
      	TIME_REGISTERED TIMESTAMP,
              KEY_HANDLE VARCHAR(200) NOT NULL,
              DEVICE_DATA VARCHAR(2048) NOT NULL,
            PRIMARY KEY (TENANT_ID, DOMAIN_NAME, USER_NAME, KEY_HANDLE));

      DROP TABLE IF EXISTS WF_REQUEST;
      CREATE TABLE WF_REQUEST (
          UUID VARCHAR (45),
          CREATED_BY VARCHAR (255),
          TENANT_ID INTEGER DEFAULT -1,
          OPERATION_TYPE VARCHAR (50),
          CREATED_AT TIMESTAMP,
          UPDATED_AT TIMESTAMP,
          STATUS VARCHAR (30),
          REQUEST BYTEA,
          PRIMARY KEY (UUID)
      );

      DROP TABLE IF EXISTS WF_BPS_PROFILE;
      CREATE TABLE WF_BPS_PROFILE (
          PROFILE_NAME VARCHAR(45),
          HOST_URL_MANAGER VARCHAR(255),
          HOST_URL_WORKER VARCHAR(255),
          USERNAME VARCHAR(45),
          PASSWORD VARCHAR(1023),
          CALLBACK_HOST VARCHAR (45),
          TENANT_ID INTEGER DEFAULT -1,
          PRIMARY KEY (PROFILE_NAME, TENANT_ID)
      );

      DROP TABLE IF EXISTS WF_WORKFLOW;
      CREATE TABLE WF_WORKFLOW(
          ID VARCHAR (45),
          WF_NAME VARCHAR (45),
          DESCRIPTION VARCHAR (255),
          TEMPLATE_ID VARCHAR (45),
          IMPL_ID VARCHAR (45),
          TENANT_ID INTEGER DEFAULT -1,
          PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS WF_WORKFLOW_ASSOCIATION;
      DROP SEQUENCE IF EXISTS WF_WORKFLOW_ASSOCIATION_PK_SEQ;
      CREATE SEQUENCE WF_WORKFLOW_ASSOCIATION_PK_SEQ;
      CREATE TABLE WF_WORKFLOW_ASSOCIATION(
          ID INTEGER DEFAULT NEXTVAL('WF_WORKFLOW_ASSOCIATION_PK_SEQ'),
          ASSOC_NAME VARCHAR (45),
          EVENT_ID VARCHAR(45),
          ASSOC_CONDITION VARCHAR (2000),
          WORKFLOW_ID VARCHAR (45),
          IS_ENABLED CHAR (1) DEFAULT '1',
          TENANT_ID INTEGER DEFAULT -1,
          PRIMARY KEY(ID),
          FOREIGN KEY (WORKFLOW_ID) REFERENCES WF_WORKFLOW(ID)ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS WF_WORKFLOW_CONFIG_PARAM;
      CREATE TABLE WF_WORKFLOW_CONFIG_PARAM(
          WORKFLOW_ID VARCHAR (45),
          PARAM_NAME VARCHAR (45),
          PARAM_VALUE VARCHAR (1000),
          PARAM_QNAME VARCHAR (45),
          PARAM_HOLDER VARCHAR (45),
          TENANT_ID INTEGER DEFAULT -1,
          PRIMARY KEY (WORKFLOW_ID, PARAM_NAME, PARAM_QNAME, PARAM_HOLDER),
          FOREIGN KEY (WORKFLOW_ID) REFERENCES WF_WORKFLOW(ID)ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS WF_REQUEST_ENTITY_RELATIONSHIP;
      CREATE TABLE WF_REQUEST_ENTITY_RELATIONSHIP(
        REQUEST_ID VARCHAR (45),
        ENTITY_NAME VARCHAR (255),
        ENTITY_TYPE VARCHAR (50),
        TENANT_ID INTEGER DEFAULT -1,
        PRIMARY KEY(REQUEST_ID, ENTITY_NAME, ENTITY_TYPE, TENANT_ID),
        FOREIGN KEY (REQUEST_ID) REFERENCES WF_REQUEST(UUID)ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS WF_WORKFLOW_REQUEST_RELATION;
      CREATE TABLE WF_WORKFLOW_REQUEST_RELATION(
        RELATIONSHIP_ID VARCHAR (45),
        WORKFLOW_ID VARCHAR (45),
        REQUEST_ID VARCHAR (45),
        UPDATED_AT TIMESTAMP,
        STATUS VARCHAR (30),
        TENANT_ID INTEGER DEFAULT -1,
        PRIMARY KEY (RELATIONSHIP_ID),
        FOREIGN KEY (WORKFLOW_ID) REFERENCES WF_WORKFLOW(ID)ON DELETE CASCADE,
        FOREIGN KEY (REQUEST_ID) REFERENCES WF_REQUEST(UUID)ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_RECOVERY_DATA;
      CREATE TABLE IDN_RECOVERY_DATA (
        USER_NAME VARCHAR(255) NOT NULL,
        USER_DOMAIN VARCHAR(127) NOT NULL,
        TENANT_ID INTEGER DEFAULT -1,
        CODE VARCHAR(255) NOT NULL,
        SCENARIO VARCHAR(255) NOT NULL,
        STEP VARCHAR(127) NOT NULL,
        TIME_CREATED TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        REMAINING_SETS VARCHAR(2500) DEFAULT NULL,
        PRIMARY KEY(USER_NAME, USER_DOMAIN, TENANT_ID, SCENARIO,STEP),
        UNIQUE(CODE)
      );

      DROP TABLE IF EXISTS IDN_PASSWORD_HISTORY_DATA;
      CREATE SEQUENCE IDN_PASSWORD_HISTORY_DATA_PK_SEQ;
      CREATE TABLE IDN_PASSWORD_HISTORY_DATA (
        ID INTEGER DEFAULT NEXTVAL('IDN_PASSWORD_HISTORY_DATA_PK_SEQ'),
        USER_NAME   VARCHAR(255) NOT NULL,
        USER_DOMAIN VARCHAR(127) NOT NULL,
        TENANT_ID   INTEGER DEFAULT -1,
        SALT_VALUE  VARCHAR(255),
        HASH        VARCHAR(255) NOT NULL,
        TIME_CREATED TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (ID),
        UNIQUE (USER_NAME,USER_DOMAIN,TENANT_ID,SALT_VALUE,HASH)
      );

      DROP TABLE IF EXISTS IDN_CLAIM_DIALECT;
      DROP SEQUENCE IF EXISTS IDN_CLAIM_DIALECT_SEQ;
      CREATE SEQUENCE IDN_CLAIM_DIALECT_SEQ;
      CREATE TABLE IDN_CLAIM_DIALECT (
        ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_DIALECT_SEQ'),
        DIALECT_URI VARCHAR (255) NOT NULL,
        TENANT_ID INTEGER NOT NULL,
        PRIMARY KEY (ID),
        CONSTRAINT DIALECT_URI_CONSTRAINT UNIQUE (DIALECT_URI, TENANT_ID)
      );

      DROP TABLE IF EXISTS IDN_CLAIM;
      DROP SEQUENCE IF EXISTS IDN_CLAIM_SEQ;
      CREATE SEQUENCE IDN_CLAIM_SEQ;
      CREATE TABLE IDN_CLAIM (
        ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_SEQ'),
        DIALECT_ID INTEGER,
        CLAIM_URI VARCHAR (255) NOT NULL,
        TENANT_ID INTEGER NOT NULL,
        PRIMARY KEY (ID),
        FOREIGN KEY (DIALECT_ID) REFERENCES IDN_CLAIM_DIALECT(ID) ON DELETE CASCADE,
        CONSTRAINT CLAIM_URI_CONSTRAINT UNIQUE (DIALECT_ID, CLAIM_URI, TENANT_ID)
      );

      DROP TABLE IF EXISTS IDN_CLAIM_MAPPED_ATTRIBUTE;
      DROP SEQUENCE IF EXISTS IDN_CLAIM_MAPPED_ATTRIBUTE_SEQ;
      CREATE SEQUENCE IDN_CLAIM_MAPPED_ATTRIBUTE_SEQ;
      CREATE TABLE IDN_CLAIM_MAPPED_ATTRIBUTE (
        ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_MAPPED_ATTRIBUTE_SEQ'),
        LOCAL_CLAIM_ID INTEGER,
        USER_STORE_DOMAIN_NAME VARCHAR (255) NOT NULL,
        ATTRIBUTE_NAME VARCHAR (255) NOT NULL,
        TENANT_ID INTEGER NOT NULL,
        PRIMARY KEY (ID),
        FOREIGN KEY (LOCAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
        CONSTRAINT USER_STORE_DOMAIN_CONSTRAINT UNIQUE (LOCAL_CLAIM_ID, USER_STORE_DOMAIN_NAME, TENANT_ID)
      );

      DROP TABLE IF EXISTS IDN_CLAIM_PROPERTY;
      DROP SEQUENCE IF EXISTS IDN_CLAIM_PROPERTY_SEQ;
      CREATE SEQUENCE IDN_CLAIM_PROPERTY_SEQ;
      CREATE TABLE IDN_CLAIM_PROPERTY (
        ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_PROPERTY_SEQ'),
        LOCAL_CLAIM_ID INTEGER,
        PROPERTY_NAME VARCHAR (255) NOT NULL,
        PROPERTY_VALUE VARCHAR (255) NOT NULL,
        TENANT_ID INTEGER NOT NULL,
        PRIMARY KEY (ID),
        FOREIGN KEY (LOCAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
        CONSTRAINT PROPERTY_NAME_CONSTRAINT UNIQUE (LOCAL_CLAIM_ID, PROPERTY_NAME, TENANT_ID)
      );

      DROP TABLE IF EXISTS IDN_CLAIM_MAPPING;
      DROP SEQUENCE IF EXISTS IDN_CLAIM_MAPPING_SEQ;
      CREATE SEQUENCE IDN_CLAIM_MAPPING_SEQ;
      CREATE TABLE IDN_CLAIM_MAPPING (
        ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_MAPPING_SEQ'),
        EXT_CLAIM_ID INTEGER NOT NULL,
        MAPPED_LOCAL_CLAIM_ID INTEGER NOT NULL,
        TENANT_ID INTEGER NOT NULL,
        PRIMARY KEY (ID),
        FOREIGN KEY (EXT_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
        FOREIGN KEY (MAPPED_LOCAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
        CONSTRAINT EXT_TO_LOC_MAPPING_CONSTRN UNIQUE (EXT_CLAIM_ID, TENANT_ID)
      );

      DROP TABLE IF EXISTS IDN_SAML2_ASSERTION_STORE;
      DROP SEQUENCE IF EXISTS IDN_SAML2_ASSERTION_STORE_SEQ;
      CREATE SEQUENCE IDN_SAML2_ASSERTION_STORE_SEQ;
      CREATE TABLE IDN_SAML2_ASSERTION_STORE (
        ID INTEGER DEFAULT NEXTVAL('IDN_SAML2_ASSERTION_STORE_SEQ'),
        SAML2_ID  VARCHAR(255) ,
        SAML2_ISSUER  VARCHAR(255) ,
        SAML2_SUBJECT  VARCHAR(255) ,
        SAML2_SESSION_INDEX  VARCHAR(255) ,
        SAML2_AUTHN_CONTEXT_CLASS_REF  VARCHAR(255) ,
        SAML2_ASSERTION  VARCHAR(4096) ,
        PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS IDN_SAML2_ARTIFACT_STORE;
      DROP SEQUENCE IF EXISTS IDN_SAML2_ARTIFACT_STORE_SEQ;
      CREATE SEQUENCE IDN_SAML2_ARTIFACT_STORE_SEQ;
      CREATE TABLE IDN_SAML2_ARTIFACT_STORE (
        ID INTEGER DEFAULT NEXTVAL('IDN_SAML2_ARTIFACT_STORE_SEQ'),
        SOURCE_ID VARCHAR(255) NOT NULL,
        MESSAGE_HANDLER VARCHAR(255) NOT NULL,
        AUTHN_REQ_DTO BYTEA NOT NULL,
        SESSION_ID VARCHAR(255) NOT NULL,
        INIT_TIMESTAMP TIMESTAMP NOT NULL,
        EXP_TIMESTAMP TIMESTAMP NOT NULL,
        ASSERTION_ID VARCHAR(255),
        PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS IDN_OIDC_JTI;
      CREATE TABLE IDN_OIDC_JTI (
        JWT_ID VARCHAR(255) NOT NULL,
        EXP_TIME TIMESTAMP NOT NULL,
        TIME_CREATED TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (JWT_ID)
      );

      DROP TABLE IF EXISTS IDN_OIDC_PROPERTY;
      DROP SEQUENCE IF EXISTS IDN_OIDC_PROPERTY_SEQ;
      CREATE SEQUENCE IDN_OIDC_PROPERTY_SEQ;
      CREATE TABLE IDN_OIDC_PROPERTY (
        ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_PROPERTY_SEQ'),
        TENANT_ID  INTEGER,
        CONSUMER_KEY  VARCHAR(255) ,
        PROPERTY_KEY  VARCHAR(255) NOT NULL,
        PROPERTY_VALUE  VARCHAR(2047) ,
        PRIMARY KEY (ID) ,
        FOREIGN KEY (CONSUMER_KEY) REFERENCES IDN_OAUTH_CONSUMER_APPS(CONSUMER_KEY) ON DELETE CASCADE
      );
      DROP TABLE IF EXISTS IDN_OIDC_REQ_OBJECT_REFERENCE;
      DROP SEQUENCE IF EXISTS IDN_OIDC_REQUEST_OBJECT_REF_SEQ;
      CREATE SEQUENCE IDN_OIDC_REQUEST_OBJECT_REF_SEQ;
      CREATE TABLE IDN_OIDC_REQ_OBJECT_REFERENCE (
        ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_REQUEST_OBJECT_REF_SEQ'),
        CONSUMER_KEY_ID INTEGER ,
        CODE_ID VARCHAR(255) ,
        TOKEN_ID VARCHAR(255) ,
        SESSION_DATA_KEY VARCHAR(255),
        PRIMARY KEY (ID),
        FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE,
        FOREIGN KEY (TOKEN_ID) REFERENCES IDN_OAUTH2_ACCESS_TOKEN(TOKEN_ID) ON DELETE CASCADE,
        FOREIGN KEY (CODE_ID) REFERENCES IDN_OAUTH2_AUTHORIZATION_CODE(CODE_ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_OIDC_REQ_OBJECT_CLAIMS;
      DROP SEQUENCE IF EXISTS IDN_OIDC_REQ_OBJECT_CLAIMS_SEQ;
      CREATE SEQUENCE IDN_OIDC_REQ_OBJECT_CLAIMS_SEQ;
      CREATE TABLE IDN_OIDC_REQ_OBJECT_CLAIMS (
        ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_REQ_OBJECT_CLAIMS_SEQ'),
        REQ_OBJECT_ID INTEGER,
        CLAIM_ATTRIBUTE VARCHAR(255) ,
        ESSENTIAL CHAR(1) NOT NULL DEFAULT '0' ,
        VALUE VARCHAR(255) ,
        IS_USERINFO CHAR(1) NOT NULL DEFAULT '0',
        PRIMARY KEY (ID),
        FOREIGN KEY (REQ_OBJECT_ID) REFERENCES IDN_OIDC_REQ_OBJECT_REFERENCE (ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_OIDC_REQ_OBJ_CLAIM_VALUES;
      DROP SEQUENCE IF EXISTS IDN_OIDC_REQ_OBJECT_CLAIM_VALUES_SEQ;
      CREATE SEQUENCE IDN_OIDC_REQ_OBJECT_CLAIM_VALUES_SEQ;
      CREATE TABLE IDN_OIDC_REQ_OBJ_CLAIM_VALUES (
        ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_REQ_OBJECT_CLAIM_VALUES_SEQ'),
        REQ_OBJECT_CLAIMS_ID INTEGER ,
        CLAIM_VALUES VARCHAR(255) ,
        PRIMARY KEY (ID),
        FOREIGN KEY (REQ_OBJECT_CLAIMS_ID) REFERENCES IDN_OIDC_REQ_OBJECT_CLAIMS(ID) ON DELETE CASCADE
      );

      DROP TABLE IF EXISTS IDN_CERTIFICATE;
      DROP SEQUENCE IF EXISTS IDN_CERTIFICATE_PK_SEQ;
      CREATE SEQUENCE IDN_CERTIFICATE_PK_SEQ;
      CREATE TABLE IDN_CERTIFICATE (
                  ID INTEGER DEFAULT NEXTVAL('IDN_CERTIFICATE_PK_SEQ'),
                  NAME VARCHAR(100),
                  CERTIFICATE_IN_PEM BYTEA,
                  TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT CERTIFICATE_UNIQUE_KEY UNIQUE (NAME, TENANT_ID),
                  PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS IDN_OIDC_SCOPE;
      DROP SEQUENCE IF EXISTS IDN_OIDC_SCOPE_PK_SEQ;
      CREATE SEQUENCE IDN_OIDC_SCOPE_PK_SEQ;
      CREATE TABLE IDN_OIDC_SCOPE (
                  ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_SCOPE_PK_SEQ'),
                  NAME VARCHAR(255),
                  TENANT_ID INTEGER DEFAULT -1,
                  PRIMARY KEY (ID)
      );

      DROP TABLE IF EXISTS IDN_OIDC_SCOPE_CLAIM_MAPPING;
      DROP SEQUENCE IF EXISTS IDN_OIDC_SCOPE_CLAIM_MAPPING_PK_SEQ;
      CREATE SEQUENCE IDN_OIDC_SCOPE_CLAIM_MAPPING_PK_SEQ;
      CREATE TABLE IDN_OIDC_SCOPE_CLAIM_MAPPING (
                  ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_SCOPE_CLAIM_MAPPING_PK_SEQ'),
                  SCOPE_ID INTEGER,
                  EXTERNAL_CLAIM_ID INTEGER,
                  PRIMARY KEY (ID),
                  FOREIGN KEY (SCOPE_ID) REFERENCES IDN_OIDC_SCOPE(ID) ON DELETE CASCADE,
                  FOREIGN KEY (EXTERNAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE
      );



      DROP TABLE IF EXISTS IDN_FUNCTION_LIBRARY;
      CREATE TABLE IDN_FUNCTION_LIBRARY (
      	NAME VARCHAR(255) NOT NULL,
      	DESCRIPTION VARCHAR(1023),
      	TYPE VARCHAR(255) NOT NULL,
      	TENANT_ID INTEGER NOT NULL,
      	DATA BYTEA NOT NULL,
      	PRIMARY KEY (TENANT_ID,NAME)
      );

      DROP TABLE IF EXISTS IDN_TEMPLATE_MGT;
      CREATE SEQUENCE IDN_TEMPLATE_MGT_SEQ;
      CREATE TABLE IDN_TEMPLATE_MGT (
        TEMPLATE_ID INTEGER DEFAULT NEXTVAL('IDN_TEMPLATE_MGT_SEQ'),
        TENANT_ID INTEGER NOT NULL,
        NAME   VARCHAR(255) NOT NULL,
        USER_DOMAIN VARCHAR(127) NOT NULL,
        DESCRIPTION VARCHAR(1023),
        TEMPLATE_SCRIPT BYTEA NOT NULL,
        PRIMARY KEY (TEMPLATE_ID),
        UNIQUE (TENANT_ID,NAME)
      );

      -- --------------------------- INDEX CREATION -----------------------------
      -- IDN_OAUTH2_ACCESS_TOKEN --
      CREATE INDEX IDX_TC ON IDN_OAUTH2_ACCESS_TOKEN(TIME_CREATED);
      CREATE INDEX IDX_ATH ON IDN_OAUTH2_ACCESS_TOKEN(ACCESS_TOKEN_HASH);
      CREATE INDEX IDX_AT_CK_AU ON IDN_OAUTH2_ACCESS_TOKEN(CONSUMER_KEY_ID, AUTHZ_USER, TOKEN_STATE, USER_TYPE);
      CREATE INDEX IDX_AT_TI_UD ON IDN_OAUTH2_ACCESS_TOKEN(AUTHZ_USER, TENANT_ID, TOKEN_STATE, USER_DOMAIN);
      CREATE INDEX IDX_AT_AU_TID_UD_TS_CKID ON IDN_OAUTH2_ACCESS_TOKEN(AUTHZ_USER, TENANT_ID, USER_DOMAIN, TOKEN_STATE, CONSUMER_KEY_ID);
      CREATE INDEX IDX_AT_AT ON IDN_OAUTH2_ACCESS_TOKEN(ACCESS_TOKEN);
      CREATE INDEX IDX_AT_AU_CKID_TS_UT ON IDN_OAUTH2_ACCESS_TOKEN(AUTHZ_USER, CONSUMER_KEY_ID, TOKEN_STATE, USER_TYPE);
      CREATE INDEX IDX_AT_RTH ON IDN_OAUTH2_ACCESS_TOKEN(REFRESH_TOKEN_HASH);
      CREATE INDEX IDX_AT_RT ON IDN_OAUTH2_ACCESS_TOKEN(REFRESH_TOKEN);

      -- IDN_OAUTH2_AUTHORIZATION_CODE --
      CREATE INDEX IDX_AUTHORIZATION_CODE_HASH ON IDN_OAUTH2_AUTHORIZATION_CODE (AUTHORIZATION_CODE_HASH, CONSUMER_KEY_ID);
      CREATE INDEX IDX_AUTHORIZATION_CODE_AU_TI ON IDN_OAUTH2_AUTHORIZATION_CODE (AUTHZ_USER, TENANT_ID, USER_DOMAIN, STATE);
      CREATE INDEX IDX_AC_CKID ON IDN_OAUTH2_AUTHORIZATION_CODE(CONSUMER_KEY_ID);
      CREATE INDEX IDX_AC_TID ON IDN_OAUTH2_AUTHORIZATION_CODE(TOKEN_ID);
      CREATE INDEX IDX_AC_AC_CKID ON IDN_OAUTH2_AUTHORIZATION_CODE(AUTHORIZATION_CODE, CONSUMER_KEY_ID);

      -- IDN_SCIM_GROUP --
      CREATE INDEX IDX_IDN_SCIM_GROUP_TI_RN ON IDN_SCIM_GROUP (TENANT_ID, ROLE_NAME);
      CREATE INDEX IDX_IDN_SCIM_GROUP_TI_RN_AN ON IDN_SCIM_GROUP (TENANT_ID, ROLE_NAME, ATTR_NAME);

      -- IDN_AUTH_SESSION_STORE --
      CREATE INDEX IDX_IDN_AUTH_SESSION_TIME ON IDN_AUTH_SESSION_STORE (TIME_CREATED);

      -- IDN_AUTH_TEMP_SESSION_STORE --
      CREATE INDEX IDX_IDN_AUTH_TMP_SESSION_TIME ON IDN_AUTH_TEMP_SESSION_STORE (TIME_CREATED);

      -- IDN_OIDC_SCOPE_CLAIM_MAPPING --
      CREATE INDEX IDX_AT_SI_ECI ON IDN_OIDC_SCOPE_CLAIM_MAPPING(SCOPE_ID, EXTERNAL_CLAIM_ID);

      -- IDN_OAUTH2_SCOPE --
      CREATE INDEX IDX_SC_TID ON IDN_OAUTH2_SCOPE(TENANT_ID);
      CREATE INDEX IDX_SC_N_TID ON IDN_OAUTH2_SCOPE(NAME, TENANT_ID);

      -- IDN_OAUTH2_SCOPE_BINDING --
      CREATE INDEX IDX_SB_SCPID ON IDN_OAUTH2_SCOPE_BINDING(SCOPE_ID);

      -- IDN_OIDC_REQ_OBJECT_REFERENCE --
      CREATE INDEX IDX_OROR_TID ON IDN_OIDC_REQ_OBJECT_REFERENCE(TOKEN_ID);

      -- IDN_OAUTH2_ACCESS_TOKEN_SCOPE --
      CREATE INDEX IDX_ATS_TID ON IDN_OAUTH2_ACCESS_TOKEN_SCOPE(TOKEN_ID);

      -- SP_TEMPLATE --
      CREATE INDEX IDX_SP_TEMPLATE ON SP_TEMPLATE (TENANT_ID, NAME);
      "

      ## ConfigMap with scripts to be run at first boot
      ## NOTE: This will override initdbScripts
      # initdbScriptsConfigMap:

      ## Secret with scripts to be run at first boot (in case it contains sensitive information)
      ## NOTE: This can work along initdbScripts or initdbScriptsConfigMap
      # initdbScriptsSecret:

      ## Optional duration in seconds the pod needs to terminate gracefully.
      ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
      ##
      # terminationGracePeriodSeconds: 30

      ## PostgreSQL service configuration
      service:
        ## PosgresSQL service type
        type: ClusterIP
        # clusterIP: None
        port: 5432

        ## Specify the nodePort value for the LoadBalancer and NodePort service types.
        ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
        ##
        # nodePort:

        ## Provide any additional annotations which may be required. This can be used to
        annotations: {}
        ## Set the LoadBalancer service type to internal only.
        ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
        ##
        # loadBalancerIP:

        ## Load Balancer sources
        ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
        ##
        # loadBalancerSourceRanges:
        # - 10.10.10.0/24

      ## PostgreSQL data Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
persistence:
  enabled: true
  ## A manually managed Persistent Volume and Claim
  ## If defined, PVC must be created manually before volume will be bound
  ## The value is evaluated as a template, so, for example, the name can depend on .Release or .Chart
  ##
  # existingClaim:

  ## The path the volume will be mounted at, useful when using different
  ## PostgreSQL images.
  ##
  mountPath: /bitnami/postgresql

  ## The subdirectory of the volume to mount to, useful in dev environments
  ## and one PV for multiple services.
  ##
  subPath: ""

  # storageClass: "-"
  accessModes:
    - ReadWriteOnce
  size: 8Gi
  annotations: {}

## updateStrategy for PostgreSQL StatefulSet and its slaves StatefulSets
## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
updateStrategy:
  type: RollingUpdate

##
## PostgreSQL Master parameters
##
master:
  ## Node, affinity and tolerations labels for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  nodeSelector: {}
  affinity: {}
  tolerations: []
  podLabels: {}
  podAnnotations: {}
  ## Additional PostgreSQL Master Volume mounts
  ##
  extraVolumeMounts: []
  ## Additional PostgreSQL Master Volumes
  ##
  extraVolumes: []

##
## PostgreSQL Slave parameters
##
slave:
  ## Node, affinity and tolerations labels for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  nodeSelector: {}
  affinity: {}
  tolerations: []
  podLabels: {}
  podAnnotations: {}
  ## Additional PostgreSQL Slave Volume mounts
  ##
  extraVolumeMounts: []
  ## Additional PostgreSQL Slave Volumes
  ##
  extraVolumes: []

## Configure resource requests and limits
## ref: http://kubernetes.io/docs/user-guide/compute-resources/
##
resources:
  requests:
    memory: 256Mi
    cpu: 250m

networkPolicy:
  ## Enable creation of NetworkPolicy resources.
  ##
  enabled: false

  ## The Policy model to apply. When set to false, only pods with the correct
  ## client label will have network access to the port PostgreSQL is listening
  ## on. When true, PostgreSQL will accept connections from any source
  ## (with the correct destination port).
  ##
  allowExternal: true

## Configure extra options for liveness and readiness probes
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes)
livenessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  enabled: true
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

## Configure metrics exporter
##
metrics:
  enabled: false
  # resources: {}
  service:
    type: ClusterIP
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9187"
    loadBalancerIP:
  serviceMonitor:
    enabled: false
    additionalLabels: {}
    # namespace: monitoring
    # interval: 30s
    # scrapeTimeout: 10s
  image:
    registry: docker.io
    repository: wrouesnel/postgres_exporter
    tag: v0.4.7
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName
  ## Pod Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  ##
  securityContext:
    enabled: false
    runAsUser: 1001
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes)
  ## Configure extra options for liveness and readiness probes
  livenessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1

  readinessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1

# Define custom environment variables to pass to the image here
extraEnv: {}
