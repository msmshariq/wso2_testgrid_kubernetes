## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry and imagePullSecrets
##
global:
  postgresql: {}
#   imageRegistry: myRegistryName
#   imagePullSecrets:
#     - myRegistryKeySecretName

## Bitnami PostgreSQL image version
## ref: https://hub.docker.com/r/bitnami/postgresql/tags/
##
image:
  registry: docker.io
  repository: bitnami/postgresql
  tag: 11.3.0-debian-9-r38
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
  ##
  pullPolicy: Always
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  # pullSecrets:
  #   - myRegistryKeySecretName

  ## Set to true if you would like to see extra information on logs
  ## It turns BASH and NAMI debugging in minideb
  ## ref:  https://github.com/bitnami/minideb-extras/#turn-on-bash-debugging
  debug: false

##
## Init containers parameters:
## volumePermissions: Change the owner of the persist volume mountpoint to RunAsUser:fsGroup
##
volumePermissions:
  enabled: true
  image:
    registry: docker.io
    repository: bitnami/minideb
    tag: latest
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    ##
    pullPolicy: Always
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName
  ## Init container Security Context
  securityContext:
    runAsUser: 0

## Use an alternate scheduler, e.g. "stork".
## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
##
# schedulerName:

## Pod Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
##
securityContext:
  enabled: true
  fsGroup: 1001
  runAsUser: 1001

## Pod Service Account
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
serviceAccount:
  enabled: false
  ## Name of an already existing service account. Setting this value disables the automatic service account creation.
  # name:

replication:
  enabled: false
  user: repl_user
  password: repl_password
  slaveReplicas: 1
  ## Set synchronous commit mode: on, off, remote_apply, remote_write and local
  ## ref: https://www.postgresql.org/docs/9.6/runtime-config-wal.html#GUC-WAL-LEVEL
  synchronousCommit: "off"
  ## From the number of `slaveReplicas` defined above, set the number of those that will have synchronous replication
  ## NOTE: It cannot be > slaveReplicas
  numSynchronousReplicas: 0
  ## Replication Cluster application name. Useful for defining multiple replication policies
  applicationName: my_application

## PostgreSQL admin user
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
postgresqlUsername: wso2carbon

## PostgreSQL password
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
##
postgresqlPassword: wso2carbon

## PostgreSQL password using existing secret
## existingSecret: secret

## Mount PostgreSQL secret as a file instead of passing environment variable
# usePasswordFile: false

## Create a database
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#creating-a-database-on-first-run
##
postgresqlDatabase: wso2carbon

## PostgreSQL data dir
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
##
postgresqlDataDir: /bitnami/postgresql/data

## Specify extra initdb args
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
##
# postgresqlInitdbArgs:

## Specify a custom location for the PostgreSQL transaction log
## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
##
# postgresqlInitdbWalDir:


## PostgreSQL configuration
## Specify runtime configuration parameters as a dict, using camelCase, e.g.
## {"sharedBuffers": "500MB"}
## Alternatively, you can put your postgresql.conf under the files/ directory
## ref: https://www.postgresql.org/docs/current/static/runtime-config.html
##
# postgresqlConfiguration:

## PostgreSQL extended configuration
## As above, but _appended_ to the main configuration
## Alternatively, you can put your *.conf under the files/conf.d/ directory
## https://github.com/bitnami/bitnami-docker-postgresql#allow-settings-to-be-loaded-from-files-other-than-the-default-postgresqlconf
##
# postgresqlExtendedConf:

## PostgreSQL client authentication configuration
## Specify content for pg_hba.conf
## Default: do not create pg_hba.conf
## Alternatively, you can put your pg_hba.conf under the files/ directory
# pgHbaConfiguration: |-
#   local all all trust
#   host all all localhost trust
#   host mydatabase mysuser 192.168.0.0/24 md5

## ConfigMap with PostgreSQL configuration
## NOTE: This will override postgresqlConfiguration and pgHbaConfiguration
# configurationConfigMap:

## ConfigMap with PostgreSQL extended configuration
# extendedConfConfigMap:

## initdb scripts
## Specify dictionary of scripts to be run at first boot
## Alternatively, you can put your scripts under the files/docker-entrypoint-initdb.d directory
##
# initdbScripts:
#   my_init_script.sh: |
#      #!/bin/sh
#      echo "Do something."

initdbScripts:
      init.sql: |
            DROP DATABASE IF EXISTS WSO2AM_COMMON_DB;
            DROP DATABASE IF EXISTS WSO2AM_APIMGT_DB;
            DROP DATABASE IF EXISTS WSO2AM_STAT_DB;

            CREATE DATABASE "WSO2AM_COMMON_DB";
            CREATE DATABASE "WSO2AM_APIMGT_DB";
            CREATE DATABASE "WSO2AM_STAT_DB";

            \c WSO2AM_COMMON_DB;

            DROP TABLE IF EXISTS REG_CLUSTER_LOCK;
            CREATE TABLE REG_CLUSTER_LOCK (
                         REG_LOCK_NAME VARCHAR (20),
                         REG_LOCK_STATUS VARCHAR (20),
                         REG_LOCKED_TIME TIMESTAMP,
                         REG_TENANT_ID INTEGER DEFAULT 0,
                         PRIMARY KEY (REG_LOCK_NAME)
            );

            DROP TABLE IF EXISTS REG_LOG;
            DROP SEQUENCE IF EXISTS REG_LOG_PK_SEQ;
            CREATE SEQUENCE REG_LOG_PK_SEQ;
            CREATE TABLE REG_LOG (
                         REG_LOG_ID INTEGER DEFAULT NEXTVAL('REG_LOG_PK_SEQ'),
                         REG_PATH VARCHAR (2000),
                         REG_USER_ID VARCHAR (31) NOT NULL,
                         REG_LOGGED_TIME TIMESTAMP NOT NULL,
                         REG_ACTION INTEGER NOT NULL,
                         REG_ACTION_DATA VARCHAR (500),
                         REG_TENANT_ID INTEGER DEFAULT 0,
                         PRIMARY KEY (REG_LOG_ID, REG_TENANT_ID)
            );

            CREATE INDEX REG_LOG_IND_BY_REG_LOGTIME ON REG_LOG(REG_LOGGED_TIME, REG_TENANT_ID);

            DROP TABLE IF EXISTS REG_PATH;
            DROP SEQUENCE IF EXISTS REG_PATH_PK_SEQ;
            CREATE SEQUENCE REG_PATH_PK_SEQ;
            CREATE TABLE REG_PATH(
                         REG_PATH_ID INTEGER DEFAULT NEXTVAL('REG_PATH_PK_SEQ'),
                         REG_PATH_VALUE VARCHAR(2000) NOT NULL,
                         REG_PATH_PARENT_ID INTEGER,
                         REG_TENANT_ID INTEGER DEFAULT 0,
                         CONSTRAINT PK_REG_PATH PRIMARY KEY(REG_PATH_ID, REG_TENANT_ID)
            );

            CREATE INDEX REG_PATH_IND_BY_PATH_VALUE ON REG_PATH(REG_PATH_VALUE, REG_TENANT_ID);
            CREATE INDEX REG_PATH_IND_BY_PATH_PARENT_ID  ON REG_PATH(REG_PATH_PARENT_ID, REG_TENANT_ID);

            DROP TABLE IF EXISTS REG_CONTENT;
            DROP SEQUENCE IF EXISTS REG_CONTENT_PK_SEQ;
            CREATE SEQUENCE REG_CONTENT_PK_SEQ;
            CREATE TABLE REG_CONTENT (
                         REG_CONTENT_ID INTEGER DEFAULT NEXTVAL('REG_CONTENT_PK_SEQ'),
                         REG_CONTENT_DATA BYTEA,
                         REG_TENANT_ID INTEGER DEFAULT 0,
                         CONSTRAINT PK_REG_CONTENT PRIMARY KEY(REG_CONTENT_ID, REG_TENANT_ID)
            );

            DROP TABLE IF EXISTS REG_CONTENT_HISTORY;
            CREATE TABLE REG_CONTENT_HISTORY (
                         REG_CONTENT_ID INTEGER NOT NULL,
                         REG_CONTENT_DATA BYTEA,
                         REG_DELETED   SMALLINT,
                         REG_TENANT_ID INTEGER DEFAULT 0,
                         CONSTRAINT PK_REG_CONTENT_HISTORY PRIMARY KEY(REG_CONTENT_ID, REG_TENANT_ID)
            );

            DROP TABLE IF EXISTS REG_RESOURCE;
            DROP SEQUENCE IF EXISTS REG_RESOURCE_PK_SEQ;
            CREATE SEQUENCE REG_RESOURCE_PK_SEQ;
            CREATE TABLE REG_RESOURCE (
                        REG_PATH_ID         INTEGER NOT NULL,
                        REG_NAME            VARCHAR(256),
                        REG_VERSION         INTEGER DEFAULT NEXTVAL('REG_RESOURCE_PK_SEQ'),
                        REG_MEDIA_TYPE      VARCHAR(500),
                        REG_CREATOR         VARCHAR(31) NOT NULL,
                        REG_CREATED_TIME    TIMESTAMP NOT NULL,
                        REG_LAST_UPDATOR    VARCHAR(31),
                        REG_LAST_UPDATED_TIME    TIMESTAMP NOT NULL,
                        REG_DESCRIPTION     VARCHAR(1000),
                        REG_CONTENT_ID      INTEGER,
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        REG_UUID VARCHAR(100) NOT NULL,
                        CONSTRAINT PK_REG_RESOURCE PRIMARY KEY(REG_VERSION, REG_TENANT_ID)
            );

            ALTER TABLE REG_RESOURCE ADD CONSTRAINT REG_RESOURCE_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
            ALTER TABLE REG_RESOURCE ADD CONSTRAINT REG_RESOURCE_FK_BY_CONTENT_ID FOREIGN KEY (REG_CONTENT_ID, REG_TENANT_ID) REFERENCES REG_CONTENT (REG_CONTENT_ID, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_IND_BY_NAME  ON REG_RESOURCE(REG_NAME, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_IND_BY_PATH_ID_NAME  ON REG_RESOURCE(REG_PATH_ID, REG_NAME, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_IND_BY_UUID  ON REG_RESOURCE(REG_UUID);
            CREATE INDEX REG_RESOURCE_IND_BY_TENANT ON REG_RESOURCE(REG_TENANT_ID, REG_UUID);
            CREATE INDEX REG_RESOURCE_IND_BY_TYPE ON REG_RESOURCE(REG_TENANT_ID, REG_MEDIA_TYPE);

            DROP TABLE IF EXISTS REG_RESOURCE_HISTORY;
            CREATE TABLE REG_RESOURCE_HISTORY (
                        REG_PATH_ID         INTEGER NOT NULL,
                        REG_NAME            VARCHAR(256),
                        REG_VERSION         INTEGER NOT NULL,
                        REG_MEDIA_TYPE      VARCHAR(500),
                        REG_CREATOR         VARCHAR(31) NOT NULL,
                        REG_CREATED_TIME    TIMESTAMP NOT NULL,
                        REG_LAST_UPDATOR    VARCHAR(31),
                        REG_LAST_UPDATED_TIME    TIMESTAMP NOT NULL,
                        REG_DESCRIPTION     VARCHAR(1000),
                        REG_CONTENT_ID      INTEGER,
                        REG_DELETED         SMALLINT,
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        REG_UUID VARCHAR(100) NOT NULL,
                        CONSTRAINT PK_REG_RESOURCE_HISTORY PRIMARY KEY(REG_VERSION, REG_TENANT_ID)
            );

            ALTER TABLE REG_RESOURCE_HISTORY ADD CONSTRAINT REG_RESOURCE_HIST_FK_BY_PATHID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
            ALTER TABLE REG_RESOURCE_HISTORY ADD CONSTRAINT REG_RESOURCE_HIST_FK_BY_CONTENT_ID FOREIGN KEY (REG_CONTENT_ID, REG_TENANT_ID) REFERENCES REG_CONTENT_HISTORY (REG_CONTENT_ID, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_HISTORY_IND_BY_NAME  ON REG_RESOURCE_HISTORY(REG_NAME, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_HISTORY_IND_BY_PATH_ID_NAME  ON REG_RESOURCE(REG_PATH_ID, REG_NAME, REG_TENANT_ID);

            DROP TABLE IF EXISTS REG_COMMENT;
            DROP SEQUENCE IF EXISTS REG_COMMENT_PK_SEQ;
            CREATE SEQUENCE REG_COMMENT_PK_SEQ;
            CREATE TABLE REG_COMMENT (
                        REG_ID        INTEGER DEFAULT NEXTVAL('REG_COMMENT_PK_SEQ'),
                        REG_COMMENT_TEXT      VARCHAR(500) NOT NULL,
                        REG_USER_ID           VARCHAR(31) NOT NULL,
                        REG_COMMENTED_TIME    TIMESTAMP NOT NULL,
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        CONSTRAINT PK_REG_COMMENT PRIMARY KEY(REG_ID, REG_TENANT_ID)
            );

            DROP TABLE IF EXISTS REG_RESOURCE_COMMENT;
            CREATE TABLE REG_RESOURCE_COMMENT (
                        REG_COMMENT_ID          INTEGER NOT NULL,
                        REG_VERSION             INTEGER,
                        REG_PATH_ID             INTEGER,
                        REG_RESOURCE_NAME       VARCHAR(256),
                        REG_TENANT_ID INTEGER DEFAULT 0
            );

            ALTER TABLE REG_RESOURCE_COMMENT ADD CONSTRAINT REG_RESOURCE_COMMENT_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
            ALTER TABLE REG_RESOURCE_COMMENT ADD CONSTRAINT REG_RESOURCE_COMMENT_FK_BY_COMMENT_ID FOREIGN KEY (REG_COMMENT_ID, REG_TENANT_ID) REFERENCES REG_COMMENT (REG_ID, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_COMMENT_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_COMMENT(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_COMMENT_IND_BY_VERSION  ON REG_RESOURCE_COMMENT(REG_VERSION, REG_TENANT_ID);

            DROP TABLE IF EXISTS REG_RATING;
            DROP SEQUENCE IF EXISTS REG_RATING_PK_SEQ;
            CREATE SEQUENCE REG_RATING_PK_SEQ;
            CREATE TABLE REG_RATING (
                        REG_ID     INTEGER DEFAULT NEXTVAL('REG_RATING_PK_SEQ'),
                        REG_RATING        INTEGER NOT NULL,
                        REG_USER_ID       VARCHAR(31) NOT NULL,
                        REG_RATED_TIME    TIMESTAMP NOT NULL,
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        CONSTRAINT PK_REG_RATING PRIMARY KEY(REG_ID, REG_TENANT_ID)
            );

            DROP TABLE IF EXISTS REG_RESOURCE_RATING;
            CREATE TABLE REG_RESOURCE_RATING (
                        REG_RATING_ID           INTEGER NOT NULL,
                        REG_VERSION             INTEGER,
                        REG_PATH_ID             INTEGER,
                        REG_RESOURCE_NAME       VARCHAR(256),
                        REG_TENANT_ID INTEGER DEFAULT 0
            );

            ALTER TABLE REG_RESOURCE_RATING ADD CONSTRAINT REG_RESOURCE_RATING_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
            ALTER TABLE REG_RESOURCE_RATING ADD CONSTRAINT REG_RESOURCE_RATING_FK_BY_RATING_ID FOREIGN KEY (REG_RATING_ID, REG_TENANT_ID) REFERENCES REG_RATING (REG_ID, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_RATING_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_RATING(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_RATING_IND_BY_VERSION  ON REG_RESOURCE_RATING(REG_VERSION, REG_TENANT_ID);

            DROP TABLE IF EXISTS REG_TAG;
            DROP SEQUENCE IF EXISTS REG_TAG_PK_SEQ;
            CREATE SEQUENCE REG_TAG_PK_SEQ;
            CREATE TABLE REG_TAG (
                        REG_ID         INTEGER DEFAULT NEXTVAL('REG_TAG_PK_SEQ'),
                        REG_TAG_NAME       VARCHAR(500) NOT NULL,
                        REG_USER_ID        VARCHAR(31) NOT NULL,
                        REG_TAGGED_TIME    TIMESTAMP NOT NULL,
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        CONSTRAINT PK_REG_TAG PRIMARY KEY(REG_ID, REG_TENANT_ID)
            );

            DROP TABLE IF EXISTS REG_RESOURCE_TAG;
            CREATE TABLE REG_RESOURCE_TAG (
                        REG_TAG_ID              INTEGER NOT NULL,
                        REG_VERSION             INTEGER,
                        REG_PATH_ID             INTEGER,
                        REG_RESOURCE_NAME       VARCHAR(256),
                        REG_TENANT_ID INTEGER DEFAULT 0
            );

            ALTER TABLE REG_RESOURCE_TAG ADD CONSTRAINT REG_RESOURCE_TAG_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
            ALTER TABLE REG_RESOURCE_TAG ADD CONSTRAINT REG_RESOURCE_TAG_FK_BY_TAG_ID FOREIGN KEY (REG_TAG_ID, REG_TENANT_ID) REFERENCES REG_TAG (REG_ID, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_TAG_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_TAG(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_TAG_IND_BY_VERSION  ON REG_RESOURCE_TAG(REG_VERSION, REG_TENANT_ID);

            DROP TABLE IF EXISTS REG_PROPERTY;
            DROP SEQUENCE IF EXISTS REG_PROPERTY_PK_SEQ;
            CREATE SEQUENCE REG_PROPERTY_PK_SEQ;
            CREATE TABLE REG_PROPERTY (
                        REG_ID         INTEGER DEFAULT NEXTVAL('REG_PROPERTY_PK_SEQ'),
                        REG_NAME       VARCHAR(100) NOT NULL,
                        REG_VALUE        VARCHAR(1000),
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        CONSTRAINT PK_REG_PROPERTY PRIMARY KEY(REG_ID, REG_TENANT_ID)
            );

            DROP TABLE IF EXISTS REG_RESOURCE_PROPERTY;
            CREATE TABLE REG_RESOURCE_PROPERTY (
                        REG_PROPERTY_ID         INTEGER NOT NULL,
                        REG_VERSION             INTEGER,
                        REG_PATH_ID             INTEGER,
                        REG_RESOURCE_NAME       VARCHAR(256),
                        REG_TENANT_ID INTEGER DEFAULT 0
            );

            ALTER TABLE REG_RESOURCE_PROPERTY ADD CONSTRAINT REG_RESOURCE_PROPERTY_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
            ALTER TABLE REG_RESOURCE_PROPERTY ADD CONSTRAINT REG_RESOURCE_PROPERTY_FK_BY_TAG_ID FOREIGN KEY (REG_PROPERTY_ID, REG_TENANT_ID) REFERENCES REG_PROPERTY (REG_ID, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_PROPERTY_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_RESOURCE_PROPERTY(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
            CREATE INDEX REG_RESOURCE_PROPERTY_IND_BY_VERSION  ON REG_RESOURCE_PROPERTY(REG_VERSION, REG_TENANT_ID);


            DROP TABLE IF EXISTS REG_ASSOCIATION;
            DROP SEQUENCE IF EXISTS REG_ASSOCIATION_PK_SEQ;
            CREATE SEQUENCE REG_ASSOCIATION_PK_SEQ;
            CREATE TABLE REG_ASSOCIATION (
                        REG_ASSOCIATION_ID INTEGER DEFAULT NEXTVAL('REG_ASSOCIATION_PK_SEQ'),
                        REG_SOURCEPATH VARCHAR (2000) NOT NULL,
                        REG_TARGETPATH VARCHAR (2000) NOT NULL,
                        REG_ASSOCIATION_TYPE VARCHAR (2000) NOT NULL,
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        PRIMARY KEY (REG_ASSOCIATION_ID, REG_TENANT_ID)
            );

            DROP TABLE IF EXISTS REG_SNAPSHOT;
            DROP SEQUENCE IF EXISTS REG_SNAPSHOT_PK_SEQ;
            CREATE SEQUENCE REG_SNAPSHOT_PK_SEQ;
            CREATE TABLE REG_SNAPSHOT (
                        REG_SNAPSHOT_ID     INTEGER DEFAULT NEXTVAL('REG_SNAPSHOT_PK_SEQ'),
                        REG_PATH_ID            INTEGER NOT NULL,
                        REG_RESOURCE_NAME      VARCHAR(255),
                        REG_RESOURCE_VIDS     BYTEA NOT NULL,
                        REG_TENANT_ID INTEGER DEFAULT 0,
                        CONSTRAINT PK_REG_SNAPSHOT PRIMARY KEY(REG_SNAPSHOT_ID, REG_TENANT_ID)
            );

            CREATE INDEX REG_SNAPSHOT_IND_BY_PATH_ID_AND_RESOURCE_NAME  ON REG_SNAPSHOT(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);

            ALTER TABLE REG_SNAPSHOT ADD CONSTRAINT REG_SNAPSHOT_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);


            -- ################################
            -- USER MANAGER TABLES
            -- ################################

            DROP TABLE IF EXISTS UM_TENANT;
            DROP SEQUENCE IF EXISTS UM_TENANT_PK_SEQ;
            CREATE SEQUENCE UM_TENANT_PK_SEQ;
            CREATE TABLE UM_TENANT (
            			UM_ID INTEGER DEFAULT NEXTVAL('UM_TENANT_PK_SEQ'),
            			UM_DOMAIN_NAME VARCHAR(255) NOT NULL,
                        UM_EMAIL VARCHAR(255),
                        UM_ACTIVE BOOLEAN DEFAULT FALSE,
            	        UM_CREATED_DATE TIMESTAMP NOT NULL,
            	        UM_USER_CONFIG BYTEA,
            			PRIMARY KEY (UM_ID),
            			UNIQUE(UM_DOMAIN_NAME));

            CREATE INDEX INDEX_UM_TENANT_UM_DOMAIN_NAME
                                ON UM_TENANT (UM_DOMAIN_NAME);


            DROP TABLE IF EXISTS UM_DOMAIN;
            DROP SEQUENCE IF EXISTS UM_DOMAIN_PK_SEQ;
            CREATE SEQUENCE UM_DOMAIN_PK_SEQ;
            CREATE TABLE UM_DOMAIN(
                        UM_DOMAIN_ID INTEGER DEFAULT NEXTVAL('UM_DOMAIN_PK_SEQ'),
                        UM_DOMAIN_NAME VARCHAR(255),
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        PRIMARY KEY (UM_DOMAIN_ID, UM_TENANT_ID)
            );


            DROP TABLE IF EXISTS UM_USER CASCADE;
            DROP SEQUENCE IF EXISTS UM_USER_PK_SEQ;
            CREATE SEQUENCE UM_USER_PK_SEQ;
            CREATE TABLE UM_USER (
                         UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_PK_SEQ'),
                         UM_USER_NAME VARCHAR(255) NOT NULL,
                         UM_USER_PASSWORD VARCHAR(255) NOT NULL,
                         UM_SALT_VALUE VARCHAR(31),
                         UM_REQUIRE_CHANGE BOOLEAN DEFAULT FALSE,
                         UM_CHANGED_TIME TIMESTAMP NOT NULL,
                         UM_TENANT_ID INTEGER DEFAULT 0,
                         PRIMARY KEY (UM_ID, UM_TENANT_ID),
                         UNIQUE(UM_USER_NAME, UM_TENANT_ID)
            );


            DROP TABLE IF EXISTS UM_SYSTEM_USER  CASCADE;
            DROP SEQUENCE IF EXISTS UM_SYSTEM_USER_PK_SEQ;
            CREATE SEQUENCE UM_SYSTEM_USER_PK_SEQ;
            CREATE TABLE UM_SYSTEM_USER (
                         UM_ID INTEGER DEFAULT NEXTVAL('UM_SYSTEM_USER_PK_SEQ'),
                         UM_USER_NAME VARCHAR(255) NOT NULL,
                         UM_USER_PASSWORD VARCHAR(255) NOT NULL,
                         UM_SALT_VALUE VARCHAR(31),
                         UM_REQUIRE_CHANGE BOOLEAN DEFAULT FALSE,
                         UM_CHANGED_TIME TIMESTAMP NOT NULL,
                         UM_TENANT_ID INTEGER DEFAULT 0,
                         PRIMARY KEY (UM_ID, UM_TENANT_ID),
                         UNIQUE(UM_USER_NAME, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_ROLE CASCADE;
            DROP SEQUENCE IF EXISTS UM_ROLE_PK_SEQ;
            CREATE SEQUENCE UM_ROLE_PK_SEQ;
            CREATE TABLE UM_ROLE (
                         UM_ID INTEGER DEFAULT NEXTVAL('UM_ROLE_PK_SEQ'),
                         UM_ROLE_NAME VARCHAR(255) NOT NULL,
                         UM_TENANT_ID INTEGER DEFAULT 0,
            		UM_SHARED_ROLE BOOLEAN DEFAULT FALSE,
                         PRIMARY KEY (UM_ID, UM_TENANT_ID),
                         UNIQUE(UM_ROLE_NAME, UM_TENANT_ID)
            );


            DROP TABLE IF EXISTS UM_MODULE CASCADE;
            DROP SEQUENCE IF EXISTS UM_MODULE_PK_SEQ;
            CREATE SEQUENCE UM_MODULE_PK_SEQ;
            CREATE TABLE UM_MODULE(
            	UM_ID INTEGER  DEFAULT NEXTVAL('UM_MODULE_PK_SEQ'),
            	UM_MODULE_NAME VARCHAR(100),
            	UNIQUE(UM_MODULE_NAME),
            	PRIMARY KEY(UM_ID)
            );

            DROP TABLE IF EXISTS UM_MODULE_ACTIONS CASCADE;
            CREATE TABLE UM_MODULE_ACTIONS(
            	UM_ACTION VARCHAR(255) NOT NULL,
            	UM_MODULE_ID INTEGER NOT NULL,
            	PRIMARY KEY(UM_ACTION, UM_MODULE_ID),
            	FOREIGN KEY (UM_MODULE_ID) REFERENCES UM_MODULE(UM_ID) ON DELETE CASCADE
            );


            DROP TABLE IF EXISTS UM_PERMISSION CASCADE;
            DROP SEQUENCE IF EXISTS UM_PERMISSION_PK_SEQ;
            CREATE SEQUENCE UM_PERMISSION_PK_SEQ;
            CREATE TABLE UM_PERMISSION (
                         UM_ID INTEGER DEFAULT NEXTVAL('UM_PERMISSION_PK_SEQ'),
                         UM_RESOURCE_ID VARCHAR(255) NOT NULL,
                         UM_ACTION VARCHAR(255) NOT NULL,
                         UM_TENANT_ID INTEGER DEFAULT 0,
            	     UM_MODULE_ID INTEGER DEFAULT 0,
            	         	 UNIQUE(UM_RESOURCE_ID,UM_ACTION, UM_TENANT_ID),
                         PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            CREATE INDEX INDEX_UM_PERMISSION_UM_RESOURCE_ID_UM_ACTION
                                ON UM_PERMISSION (UM_RESOURCE_ID, UM_ACTION, UM_TENANT_ID);


            DROP TABLE IF EXISTS UM_ROLE_PERMISSION;
            DROP SEQUENCE IF EXISTS UM_ROLE_PERMISSION_PK_SEQ;
            CREATE SEQUENCE UM_ROLE_PERMISSION_PK_SEQ;
            CREATE TABLE UM_ROLE_PERMISSION (
                         UM_ID INTEGER DEFAULT NEXTVAL('UM_ROLE_PERMISSION_PK_SEQ'),
                         UM_PERMISSION_ID INTEGER NOT NULL,
                         UM_ROLE_NAME VARCHAR(255) NOT NULL,
                         UM_IS_ALLOWED SMALLINT NOT NULL,
                         UM_TENANT_ID INTEGER DEFAULT 0,
            	     UM_DOMAIN_ID INTEGER,
                         FOREIGN KEY (UM_PERMISSION_ID, UM_TENANT_ID) REFERENCES UM_PERMISSION(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
            	     FOREIGN KEY (UM_DOMAIN_ID, UM_TENANT_ID) REFERENCES UM_DOMAIN(UM_DOMAIN_ID, UM_TENANT_ID) ON DELETE CASCADE,
                         PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            -- REMOVED UNIQUE (UM_PERMISSION_ID, UM_ROLE_ID)
            DROP TABLE IF EXISTS UM_USER_PERMISSION;
            DROP SEQUENCE IF EXISTS UM_USER_PERMISSION_PK_SEQ;
            CREATE SEQUENCE UM_USER_PERMISSION_PK_SEQ;
            CREATE TABLE UM_USER_PERMISSION (
                         UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_PERMISSION_PK_SEQ'),
                         UM_PERMISSION_ID INTEGER NOT NULL,
                         UM_USER_NAME VARCHAR(255) NOT NULL,
                         UM_IS_ALLOWED SMALLINT NOT NULL,
                         UM_TENANT_ID INTEGER DEFAULT 0,
                         FOREIGN KEY (UM_PERMISSION_ID, UM_TENANT_ID) REFERENCES UM_PERMISSION(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
                         PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            -- REMOVED UNIQUE (UM_PERMISSION_ID, UM_USER_ID)
            DROP TABLE IF EXISTS UM_USER_ROLE;
            DROP SEQUENCE IF EXISTS UM_USER_ROLE_PK_SEQ;
            CREATE SEQUENCE UM_USER_ROLE_PK_SEQ;
            CREATE TABLE UM_USER_ROLE (
                         UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_ROLE_PK_SEQ'),
                         UM_ROLE_ID INTEGER NOT NULL,
                         UM_USER_ID INTEGER NOT NULL,
                         UM_TENANT_ID INTEGER DEFAULT 0,
                         UNIQUE (UM_USER_ID, UM_ROLE_ID, UM_TENANT_ID),
                         FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_ROLE(UM_ID, UM_TENANT_ID),
                         FOREIGN KEY (UM_USER_ID, UM_TENANT_ID) REFERENCES UM_USER(UM_ID, UM_TENANT_ID),
                         PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_SHARED_USER_ROLE;
            CREATE TABLE UM_SHARED_USER_ROLE(
                UM_ROLE_ID INTEGER NOT NULL,
                UM_USER_ID INTEGER NOT NULL,
                UM_USER_TENANT_ID INTEGER NOT NULL,
                UM_ROLE_TENANT_ID INTEGER NOT NULL,
                UNIQUE(UM_USER_ID,UM_ROLE_ID,UM_USER_TENANT_ID, UM_ROLE_TENANT_ID),
                FOREIGN KEY(UM_ROLE_ID,UM_ROLE_TENANT_ID) REFERENCES UM_ROLE(UM_ID,UM_TENANT_ID) ON DELETE CASCADE ,
                FOREIGN KEY(UM_USER_ID,UM_USER_TENANT_ID) REFERENCES UM_USER(UM_ID,UM_TENANT_ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS UM_ACCOUNT_MAPPING;
            DROP SEQUENCE IF EXISTS UM_ACCOUNT_MAPPING_SEQ;
            CREATE SEQUENCE UM_ACCOUNT_MAPPING_SEQ;
            CREATE TABLE UM_ACCOUNT_MAPPING(
            	UM_ID INTEGER DEFAULT NEXTVAL('UM_ACCOUNT_MAPPING_SEQ'),
            	UM_USER_NAME VARCHAR(255) NOT NULL,
            	UM_TENANT_ID INTEGER NOT NULL,
            	UM_USER_STORE_DOMAIN VARCHAR(100),
            	UM_ACC_LINK_ID INTEGER NOT NULL,
            	UNIQUE(UM_USER_NAME, UM_TENANT_ID, UM_USER_STORE_DOMAIN, UM_ACC_LINK_ID),
            	FOREIGN KEY (UM_TENANT_ID) REFERENCES UM_TENANT(UM_ID) ON DELETE CASCADE,
            	PRIMARY KEY (UM_ID)
            );

            DROP TABLE IF EXISTS UM_USER_ATTRIBUTE;
            DROP SEQUENCE IF EXISTS UM_USER_ATTRIBUTE_PK_SEQ;
            CREATE SEQUENCE UM_USER_ATTRIBUTE_PK_SEQ;
            CREATE TABLE UM_USER_ATTRIBUTE (
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_USER_ATTRIBUTE_PK_SEQ'),
                        UM_ATTR_NAME VARCHAR(255) NOT NULL,
                        UM_ATTR_VALUE VARCHAR(1024),
                        UM_PROFILE_ID VARCHAR(255),
                        UM_USER_ID INTEGER,
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        FOREIGN KEY (UM_USER_ID, UM_TENANT_ID) REFERENCES UM_USER(UM_ID, UM_TENANT_ID),
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            CREATE INDEX UM_USER_ID_INDEX ON UM_USER_ATTRIBUTE(UM_USER_ID);

            DROP TABLE IF EXISTS UM_DIALECT CASCADE;
            DROP SEQUENCE IF EXISTS UM_DIALECT_PK_SEQ;
            CREATE SEQUENCE UM_DIALECT_PK_SEQ;
            CREATE TABLE UM_DIALECT(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_DIALECT_PK_SEQ'),
                        UM_DIALECT_URI VARCHAR(255) NOT NULL,
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        UNIQUE(UM_DIALECT_URI, UM_TENANT_ID),
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_CLAIM;
            DROP SEQUENCE IF EXISTS UM_CLAIM_PK_SEQ;
            CREATE SEQUENCE UM_CLAIM_PK_SEQ;
            CREATE TABLE UM_CLAIM(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_CLAIM_PK_SEQ'),
                        UM_DIALECT_ID INTEGER NOT NULL,
                        UM_CLAIM_URI VARCHAR(255) NOT NULL,
                        UM_DISPLAY_TAG VARCHAR(255),
                        UM_DESCRIPTION VARCHAR(255),
                        UM_MAPPED_ATTRIBUTE_DOMAIN VARCHAR(255),
                        UM_MAPPED_ATTRIBUTE VARCHAR(255),
                        UM_REG_EX VARCHAR(255),
                        UM_SUPPORTED SMALLINT,
                        UM_REQUIRED SMALLINT,
                        UM_DISPLAY_ORDER INTEGER,
            	    UM_CHECKED_ATTRIBUTE SMALLINT,
            	    UM_READ_ONLY SMALLINT,
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        UNIQUE(UM_DIALECT_ID, UM_CLAIM_URI, UM_TENANT_ID),
                        FOREIGN KEY(UM_DIALECT_ID, UM_TENANT_ID) REFERENCES UM_DIALECT(UM_ID, UM_TENANT_ID),
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_PROFILE_CONFIG;
            DROP SEQUENCE IF EXISTS UM_PROFILE_CONFIG_PK_SEQ;
            CREATE SEQUENCE UM_PROFILE_CONFIG_PK_SEQ;
            CREATE TABLE UM_PROFILE_CONFIG(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_PROFILE_CONFIG_PK_SEQ'),
                        UM_DIALECT_ID INTEGER NOT NULL,
                        UM_PROFILE_NAME VARCHAR(255),
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        FOREIGN KEY(UM_DIALECT_ID, UM_TENANT_ID) REFERENCES UM_DIALECT(UM_ID, UM_TENANT_ID),
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_CLAIM_BEHAVIOR;
            DROP SEQUENCE IF EXISTS UM_CLAIM_BEHAVIOR_PK_SEQ;
            CREATE SEQUENCE UM_CLAIM_BEHAVIOR_PK_SEQ;
            CREATE TABLE UM_CLAIM_BEHAVIOR(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_CLAIM_BEHAVIOR_PK_SEQ'),
                        UM_PROFILE_ID INTEGER,
                        UM_CLAIM_ID INTEGER,
                        UM_BEHAVIOUR SMALLINT,
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        FOREIGN KEY(UM_PROFILE_ID, UM_TENANT_ID) REFERENCES UM_PROFILE_CONFIG(UM_ID, UM_TENANT_ID),
                        FOREIGN KEY(UM_CLAIM_ID, UM_TENANT_ID) REFERENCES UM_CLAIM(UM_ID, UM_TENANT_ID),
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_HYBRID_ROLE;
            DROP SEQUENCE IF EXISTS UM_HYBRID_ROLE_PK_SEQ;
            CREATE SEQUENCE UM_HYBRID_ROLE_PK_SEQ;
            CREATE TABLE UM_HYBRID_ROLE(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_HYBRID_ROLE_PK_SEQ'),
                        UM_ROLE_NAME VARCHAR(255),
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_HYBRID_USER_ROLE;
            DROP SEQUENCE IF EXISTS UM_HYBRID_USER_ROLE_PK_SEQ;
            CREATE SEQUENCE UM_HYBRID_USER_ROLE_PK_SEQ;
            CREATE TABLE UM_HYBRID_USER_ROLE(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_HYBRID_USER_ROLE_PK_SEQ'),
                        UM_USER_NAME VARCHAR(255),
                        UM_ROLE_ID INTEGER NOT NULL,
                        UM_TENANT_ID INTEGER DEFAULT 0,
            	    UM_DOMAIN_ID INTEGER,
                        UNIQUE (UM_USER_NAME, UM_ROLE_ID, UM_TENANT_ID, UM_DOMAIN_ID),
                        FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_HYBRID_ROLE(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
            	    FOREIGN KEY (UM_DOMAIN_ID, UM_TENANT_ID) REFERENCES UM_DOMAIN(UM_DOMAIN_ID, UM_TENANT_ID) ON DELETE CASCADE,
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            DROP TABLE IF EXISTS UM_SYSTEM_ROLE;
            DROP SEQUENCE IF EXISTS UM_SYSTEM_ROLE_PK_SEQ;
            CREATE SEQUENCE UM_SYSTEM_ROLE_PK_SEQ;
            CREATE TABLE UM_SYSTEM_ROLE(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_SYSTEM_ROLE_PK_SEQ'),
                        UM_ROLE_NAME VARCHAR(255),
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            CREATE INDEX SYSTEM_ROLE_IND_BY_RN_TI ON UM_SYSTEM_ROLE(UM_ROLE_NAME, UM_TENANT_ID);

            DROP TABLE IF EXISTS UM_SYSTEM_USER_ROLE;
            DROP SEQUENCE IF EXISTS UM_SYSTEM_USER_ROLE_PK_SEQ;
            CREATE SEQUENCE UM_SYSTEM_USER_ROLE_PK_SEQ;
            CREATE TABLE UM_SYSTEM_USER_ROLE(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_SYSTEM_USER_ROLE_PK_SEQ'),
                        UM_USER_NAME VARCHAR(255),
                        UM_ROLE_ID INTEGER NOT NULL,
                        UM_TENANT_ID INTEGER DEFAULT 0,
                        UNIQUE (UM_USER_NAME, UM_ROLE_ID, UM_TENANT_ID),
                        FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_SYSTEM_ROLE(UM_ID, UM_TENANT_ID),
                        PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );



            DROP TABLE IF EXISTS UM_HYBRID_REMEMBER_ME;
            DROP SEQUENCE IF EXISTS UM_HYBRID_REMEMBER_ME_PK_SEQ;
            CREATE SEQUENCE UM_HYBRID_REMEMBER_ME_PK_SEQ;
            CREATE TABLE UM_HYBRID_REMEMBER_ME(
                        UM_ID INTEGER DEFAULT NEXTVAL('UM_HYBRID_REMEMBER_ME_PK_SEQ'),
                        UM_USER_NAME VARCHAR(255) NOT NULL,
            			UM_COOKIE_VALUE VARCHAR(1024),
            			UM_CREATED_TIME TIMESTAMP,
                        UM_TENANT_ID INTEGER DEFAULT 0,
            			PRIMARY KEY (UM_ID, UM_TENANT_ID)
            );

            BEGIN TRANSACTION;

            \c WSO2AM_APIMGT_DB;

            -- Start of IDN Tables --
            DROP TABLE IF EXISTS IDN_BASE_TABLE;
            CREATE TABLE IDN_BASE_TABLE (
                        PRODUCT_NAME VARCHAR(20),
                        PRIMARY KEY (PRODUCT_NAME)
            );

            INSERT INTO IDN_BASE_TABLE values ('WSO2 Identity Server');

            DROP TABLE IF EXISTS IDN_OAUTH_CONSUMER_APPS;
            DROP SEQUENCE IF EXISTS IDN_OAUTH_CONSUMER_APPS_PK_SEQ;
            CREATE SEQUENCE IDN_OAUTH_CONSUMER_APPS_PK_SEQ;
            CREATE TABLE IDN_OAUTH_CONSUMER_APPS (
                        ID INTEGER DEFAULT NEXTVAL('IDN_OAUTH_CONSUMER_APPS_PK_SEQ'),
                        CONSUMER_KEY VARCHAR(255),
                        CONSUMER_SECRET VARCHAR(2048),
                        USERNAME VARCHAR(255),
                        TENANT_ID INTEGER DEFAULT 0,
                        USER_DOMAIN VARCHAR(50),
                        APP_NAME VARCHAR(255),
                        OAUTH_VERSION VARCHAR(128),
                        CALLBACK_URL VARCHAR(1024),
                        GRANT_TYPES VARCHAR (1024),
                        PKCE_MANDATORY CHAR(1) DEFAULT '0',
                        PKCE_SUPPORT_PLAIN CHAR(1) DEFAULT '0',
                        APP_STATE VARCHAR (25) DEFAULT 'ACTIVE',
                        USER_ACCESS_TOKEN_EXPIRE_TIME BIGINT DEFAULT 3600,
                        APP_ACCESS_TOKEN_EXPIRE_TIME BIGINT DEFAULT 3600,
                        REFRESH_TOKEN_EXPIRE_TIME BIGINT DEFAULT 84600,
                        ID_TOKEN_EXPIRE_TIME BIGINT DEFAULT 3600,
                        CONSTRAINT CONSUMER_KEY_CONSTRAINT UNIQUE (CONSUMER_KEY),
                        PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS IDN_OAUTH2_SCOPE_VALIDATORS;
            CREATE TABLE IDN_OAUTH2_SCOPE_VALIDATORS (
            	APP_ID INTEGER NOT NULL,
            	SCOPE_VALIDATOR VARCHAR (128) NOT NULL,
            	PRIMARY KEY (APP_ID,SCOPE_VALIDATOR),
            	FOREIGN KEY (APP_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_OAUTH1A_REQUEST_TOKEN;
            CREATE TABLE IDN_OAUTH1A_REQUEST_TOKEN (
                        REQUEST_TOKEN VARCHAR(512),
                        REQUEST_TOKEN_SECRET VARCHAR(512),
                        CONSUMER_KEY_ID INTEGER,
                        CALLBACK_URL VARCHAR(1024),
                        SCOPE VARCHAR(2048),
                        AUTHORIZED VARCHAR(128),
                        OAUTH_VERIFIER VARCHAR(512),
                        AUTHZ_USER VARCHAR(512),
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (REQUEST_TOKEN),
                        FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_OAUTH1A_ACCESS_TOKEN;
            CREATE TABLE IDN_OAUTH1A_ACCESS_TOKEN (
                        ACCESS_TOKEN VARCHAR(512),
                        ACCESS_TOKEN_SECRET VARCHAR(512),
                        CONSUMER_KEY_ID INTEGER,
                        SCOPE VARCHAR(2048),
                        AUTHZ_USER VARCHAR(512),
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (ACCESS_TOKEN),
                        FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_OAUTH2_ACCESS_TOKEN;
            CREATE TABLE IDN_OAUTH2_ACCESS_TOKEN (
                        TOKEN_ID VARCHAR (255),
                        ACCESS_TOKEN VARCHAR(2048),
                        REFRESH_TOKEN VARCHAR(2048),
                        CONSUMER_KEY_ID INTEGER,
                        AUTHZ_USER VARCHAR (100),
                        TENANT_ID INTEGER,
                        USER_DOMAIN VARCHAR(50),
                        USER_TYPE VARCHAR (25),
                        GRANT_TYPE VARCHAR (50),
                        TIME_CREATED TIMESTAMP,
                        REFRESH_TOKEN_TIME_CREATED TIMESTAMP,
                        VALIDITY_PERIOD BIGINT,
                        REFRESH_TOKEN_VALIDITY_PERIOD BIGINT,
                        TOKEN_SCOPE_HASH VARCHAR(32),
                        TOKEN_STATE VARCHAR(25) DEFAULT 'ACTIVE',
                        TOKEN_STATE_ID VARCHAR (128) DEFAULT 'NONE',
                        SUBJECT_IDENTIFIER VARCHAR(255),
                        ACCESS_TOKEN_HASH VARCHAR(512),
                        REFRESH_TOKEN_HASH VARCHAR(512),
                        PRIMARY KEY (TOKEN_ID),
                        FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE,
                        CONSTRAINT CON_APP_KEY UNIQUE (CONSUMER_KEY_ID,AUTHZ_USER,TOKEN_ID,USER_DOMAIN,USER_TYPE,TOKEN_SCOPE_HASH,
                                                       TOKEN_STATE,TOKEN_STATE_ID)
            );

            CREATE INDEX IDX_AT_CK_AU ON IDN_OAUTH2_ACCESS_TOKEN(CONSUMER_KEY_ID, AUTHZ_USER, TOKEN_STATE, USER_TYPE);

            CREATE INDEX IDX_TC ON IDN_OAUTH2_ACCESS_TOKEN(TIME_CREATED);

            CREATE INDEX IDX_ATH ON IDN_OAUTH2_ACCESS_TOKEN(ACCESS_TOKEN_HASH);

            CREATE INDEX IDX_AT_TI_UD ON IDN_OAUTH2_ACCESS_TOKEN(AUTHZ_USER, TENANT_ID, TOKEN_STATE, USER_DOMAIN);

            DROP TABLE IF EXISTS IDN_OAUTH2_ACCESS_TOKEN_AUDIT;
            CREATE TABLE IF NOT EXISTS IDN_OAUTH2_ACCESS_TOKEN_AUDIT (
                        TOKEN_ID VARCHAR (255),
                        ACCESS_TOKEN VARCHAR(2048),
                        REFRESH_TOKEN VARCHAR(2048),
                        CONSUMER_KEY_ID INTEGER,
                        AUTHZ_USER VARCHAR (100),
                        TENANT_ID INTEGER,
                        USER_DOMAIN VARCHAR(50),
                        USER_TYPE VARCHAR (25),
                        GRANT_TYPE VARCHAR (50),
                        TIME_CREATED TIMESTAMP NULL,
                        REFRESH_TOKEN_TIME_CREATED TIMESTAMP NULL,
                        VALIDITY_PERIOD BIGINT,
                        REFRESH_TOKEN_VALIDITY_PERIOD BIGINT,
                        TOKEN_SCOPE_HASH VARCHAR(32),
                        TOKEN_STATE VARCHAR(25),
                        TOKEN_STATE_ID VARCHAR (128) ,
                        SUBJECT_IDENTIFIER VARCHAR(255),
                        ACCESS_TOKEN_HASH VARCHAR(512),
                        REFRESH_TOKEN_HASH VARCHAR(512),
                        INVALIDATED_TIME TIMESTAMP NULL
            );

            DROP TABLE IF EXISTS IDN_OAUTH2_AUTHORIZATION_CODE;
            CREATE TABLE IDN_OAUTH2_AUTHORIZATION_CODE (
                        CODE_ID VARCHAR (255),
                        AUTHORIZATION_CODE VARCHAR(2048),
                        CONSUMER_KEY_ID INTEGER,
            	          CALLBACK_URL VARCHAR(1024),
                        SCOPE VARCHAR(2048),
                        AUTHZ_USER VARCHAR (100),
                        TENANT_ID INTEGER,
                        USER_DOMAIN VARCHAR(50),
            	          TIME_CREATED TIMESTAMP,
            	          VALIDITY_PERIOD BIGINT,
                        STATE VARCHAR (25) DEFAULT 'ACTIVE',
                        TOKEN_ID VARCHAR(255),
                        SUBJECT_IDENTIFIER VARCHAR(255),
                        PKCE_CODE_CHALLENGE VARCHAR (255),
                        PKCE_CODE_CHALLENGE_METHOD VARCHAR(128),
                        AUTHORIZATION_CODE_HASH VARCHAR(512),
                        PRIMARY KEY (CODE_ID),
                        FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE
            );

            CREATE INDEX IDX_AUTHORIZATION_CODE_HASH ON IDN_OAUTH2_AUTHORIZATION_CODE (AUTHORIZATION_CODE_HASH,CONSUMER_KEY_ID);

            CREATE INDEX IDX_AUTHORIZATION_CODE_AU_TI ON IDN_OAUTH2_AUTHORIZATION_CODE (AUTHZ_USER,TENANT_ID, USER_DOMAIN, STATE);

            DROP TABLE IF EXISTS IDN_OAUTH2_ACCESS_TOKEN_SCOPE;
            CREATE TABLE IDN_OAUTH2_ACCESS_TOKEN_SCOPE (
                        TOKEN_ID VARCHAR (255),
                        TOKEN_SCOPE VARCHAR (60),
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (TOKEN_ID, TOKEN_SCOPE),
                        FOREIGN KEY (TOKEN_ID) REFERENCES IDN_OAUTH2_ACCESS_TOKEN(TOKEN_ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDN_OAUTH2_SCOPE;
            DROP SEQUENCE IF EXISTS IDN_OAUTH2_SCOPE_PK_SEQ;
            CREATE SEQUENCE IDN_OAUTH2_SCOPE_PK_SEQ;
            CREATE TABLE IF NOT EXISTS IDN_OAUTH2_SCOPE (
                        SCOPE_ID INTEGER DEFAULT NEXTVAL('IDN_OAUTH2_SCOPE_PK_SEQ'),
                        NAME VARCHAR(255) NOT NULL,
                        DISPLAY_NAME VARCHAR(255) NOT NULL,
                        DESCRIPTION VARCHAR(512),
                        TENANT_ID INTEGER NOT NULL DEFAULT -1,
                        PRIMARY KEY (SCOPE_ID)
            );

            DROP TABLE IF EXISTS IDN_OAUTH2_SCOPE_BINDING;
            CREATE TABLE IF NOT EXISTS IDN_OAUTH2_SCOPE_BINDING (
                        SCOPE_ID INTEGER NOT NULL,
                        SCOPE_BINDING VARCHAR(255),
                        FOREIGN KEY (SCOPE_ID) REFERENCES IDN_OAUTH2_SCOPE(SCOPE_ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_OAUTH2_RESOURCE_SCOPE;
            CREATE TABLE IF NOT EXISTS IDN_OAUTH2_RESOURCE_SCOPE (
                        RESOURCE_PATH VARCHAR(255) NOT NULL,
                        SCOPE_ID INTEGER NOT NULL,
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (RESOURCE_PATH),
                        FOREIGN KEY (SCOPE_ID) REFERENCES IDN_OAUTH2_SCOPE (SCOPE_ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_SCIM_GROUP;
            DROP SEQUENCE IF EXISTS IDN_SCIM_GROUP_PK_SEQ;
            CREATE SEQUENCE IDN_SCIM_GROUP_PK_SEQ;
            CREATE TABLE IDN_SCIM_GROUP (
            			ID INTEGER DEFAULT NEXTVAL('IDN_SCIM_GROUP_PK_SEQ'),
            			TENANT_ID INTEGER NOT NULL,
            			ROLE_NAME VARCHAR(255) NOT NULL,
                        ATTR_NAME VARCHAR(1024) NOT NULL,
            			ATTR_VALUE VARCHAR(1024),
                        PRIMARY KEY (ID)
            );
            CREATE INDEX IDX_IDN_SCIM_GROUP_TI_RN ON IDN_SCIM_GROUP (TENANT_ID, ROLE_NAME);

            CREATE INDEX IDX_IDN_SCIM_GROUP_TI_RN_AN ON IDN_SCIM_GROUP (TENANT_ID, ROLE_NAME, ATTR_NAME);

            DROP TABLE IF EXISTS IDN_OPENID_REMEMBER_ME;
            CREATE TABLE IDN_OPENID_REMEMBER_ME (
                        USER_NAME VARCHAR(255) NOT NULL,
                        TENANT_ID INTEGER DEFAULT 0,
                        COOKIE_VALUE VARCHAR(1024),
                        CREATED_TIME TIMESTAMP,
                        PRIMARY KEY (USER_NAME, TENANT_ID)
            );

            DROP TABLE IF EXISTS IDN_OPENID_USER_RPS;
            CREATE TABLE IDN_OPENID_USER_RPS (
            			USER_NAME VARCHAR(255) NOT NULL,
            			TENANT_ID INTEGER DEFAULT 0,
            			RP_URL VARCHAR(255) NOT NULL,
            			TRUSTED_ALWAYS VARCHAR(128) DEFAULT 'FALSE',
            			LAST_VISIT DATE NOT NULL,
            			VISIT_COUNT INTEGER DEFAULT 0,
            			DEFAULT_PROFILE_NAME VARCHAR(255) DEFAULT 'DEFAULT',
            			PRIMARY KEY (USER_NAME, TENANT_ID, RP_URL)
            );

            DROP TABLE IF EXISTS IDN_OPENID_ASSOCIATIONS;
            CREATE TABLE IDN_OPENID_ASSOCIATIONS (
                        HANDLE VARCHAR(255) NOT NULL,
                        ASSOC_TYPE VARCHAR(255) NOT NULL,
                        EXPIRE_IN TIMESTAMP NOT NULL,
                        MAC_KEY VARCHAR(255) NOT NULL,
                        ASSOC_STORE VARCHAR(128) DEFAULT 'SHARED',
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (HANDLE)
            );

            DROP TABLE IF EXISTS IDN_STS_STORE;
            DROP SEQUENCE IF EXISTS IDN_STS_STORE_PK_SEQ;
            CREATE SEQUENCE IDN_STS_STORE_PK_SEQ;
            CREATE TABLE IDN_STS_STORE (
                        ID INTEGER DEFAULT NEXTVAL('IDN_STS_STORE_PK_SEQ'),
                        TOKEN_ID VARCHAR(255) NOT NULL,
                        TOKEN_CONTENT BYTEA NOT NULL,
                        CREATE_DATE TIMESTAMP NOT NULL,
                        EXPIRE_DATE TIMESTAMP NOT NULL,
                        STATE INTEGER DEFAULT 0,
                        PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS IDN_IDENTITY_USER_DATA;
            CREATE TABLE IDN_IDENTITY_USER_DATA (
                        TENANT_ID INTEGER DEFAULT -1234,
                        USER_NAME VARCHAR(255) NOT NULL,
                        DATA_KEY VARCHAR(255) NOT NULL,
                        DATA_VALUE VARCHAR(2048),
                        PRIMARY KEY (TENANT_ID, USER_NAME, DATA_KEY)
            );

            DROP TABLE IF EXISTS IDN_IDENTITY_META_DATA;
            CREATE TABLE IDN_IDENTITY_META_DATA (
                        USER_NAME VARCHAR(255) NOT NULL,
                        TENANT_ID INTEGER DEFAULT -1234,
                        METADATA_TYPE VARCHAR(255) NOT NULL,
                        METADATA VARCHAR(255) NOT NULL,
                        VALID VARCHAR(255) NOT NULL,
                        PRIMARY KEY (TENANT_ID, USER_NAME, METADATA_TYPE,METADATA)
            );

            DROP TABLE IF EXISTS IDN_THRIFT_SESSION;
            CREATE TABLE IDN_THRIFT_SESSION (
                        SESSION_ID VARCHAR(255) NOT NULL,
                        USER_NAME VARCHAR(255) NOT NULL,
                        CREATED_TIME VARCHAR(255) NOT NULL,
                        LAST_MODIFIED_TIME VARCHAR(255) NOT NULL,
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (SESSION_ID)
            );

            DROP TABLE IF EXISTS IDN_AUTH_SESSION_STORE;
            CREATE TABLE IDN_AUTH_SESSION_STORE (
                        SESSION_ID VARCHAR(100) NOT NULL,
                        SESSION_TYPE VARCHAR(100) NOT NULL,
                        OPERATION VARCHAR(10) NOT NULL,
                        SESSION_OBJECT BYTEA,
                        TIME_CREATED BIGINT,
                        TENANT_ID INTEGER DEFAULT -1,
                        EXPIRY_TIME BIGINT,
                        PRIMARY KEY (SESSION_ID, SESSION_TYPE, TIME_CREATED, OPERATION)
            );

            CREATE INDEX IDX_IDN_AUTH_SESSION_TIME ON IDN_AUTH_SESSION_STORE (TIME_CREATED);


            DROP TABLE IF EXISTS IDN_AUTH_TEMP_SESSION_STORE;
            CREATE TABLE IDN_AUTH_TEMP_SESSION_STORE (
                        SESSION_ID VARCHAR(100) NOT NULL,
                        SESSION_TYPE VARCHAR(100) NOT NULL,
                        OPERATION VARCHAR(10) NOT NULL,
                        SESSION_OBJECT BYTEA,
                        TIME_CREATED BIGINT,
                        TENANT_ID INTEGER DEFAULT -1,
                        EXPIRY_TIME BIGINT,
                        PRIMARY KEY (SESSION_ID, SESSION_TYPE, TIME_CREATED, OPERATION)
            );

            CREATE INDEX IDX_IDN_AUTH_TMP_SESSION_TIME ON IDN_AUTH_TEMP_SESSION_STORE (TIME_CREATED);


            DROP TABLE IF EXISTS SP_APP;
            DROP SEQUENCE IF EXISTS SP_APP_SEQ;
            CREATE SEQUENCE SP_APP_SEQ;
            CREATE TABLE SP_APP (
                        ID INTEGER DEFAULT NEXTVAL('SP_APP_SEQ'),
                        TENANT_ID INTEGER NOT NULL,
                        APP_NAME VARCHAR (255) NOT NULL ,
                        USER_STORE VARCHAR (255) NOT NULL,
                        USERNAME VARCHAR (255) NOT NULL ,
                        DESCRIPTION VARCHAR (1024),
            	    	    ROLE_CLAIM VARCHAR (512),
                        AUTH_TYPE VARCHAR (255) NOT NULL,
                        PROVISIONING_USERSTORE_DOMAIN VARCHAR (512),
                        IS_LOCAL_CLAIM_DIALECT CHAR(1) DEFAULT '1',
                        IS_SEND_LOCAL_SUBJECT_ID CHAR(1) DEFAULT '0',
                        IS_SEND_AUTH_LIST_OF_IDPS CHAR(1) DEFAULT '0',
                        IS_USE_TENANT_DOMAIN_SUBJECT CHAR(1) DEFAULT '1',
                        IS_USE_USER_DOMAIN_SUBJECT CHAR(1) DEFAULT '1',
                        ENABLE_AUTHORIZATION CHAR(1) DEFAULT '0',
                        SUBJECT_CLAIM_URI VARCHAR (512),
                        IS_SAAS_APP CHAR(1) DEFAULT '0',
                        IS_DUMB_MODE CHAR(1) DEFAULT '0',
                        PRIMARY KEY (ID));

            ALTER TABLE SP_APP ADD CONSTRAINT APPLICATION_NAME_CONSTRAINT UNIQUE(APP_NAME, TENANT_ID);

            DROP TABLE IF EXISTS SP_METADATA;
            DROP SEQUENCE IF EXISTS SP_METADATA_SEQ;
            CREATE SEQUENCE SP_METADATA_SEQ;
            CREATE TABLE SP_METADATA (
                        ID INTEGER DEFAULT NEXTVAL('SP_METADATA_SEQ'),
                        SP_ID INTEGER,
                        NAME VARCHAR(255) NOT NULL,
                        VALUE VARCHAR(255) NOT NULL,
                        DISPLAY_NAME VARCHAR(255),
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (ID),
                        CONSTRAINT SP_METADATA_CONSTRAINT UNIQUE (SP_ID, NAME),
                        FOREIGN KEY (SP_ID) REFERENCES SP_APP(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS SP_INBOUND_AUTH;
            DROP SEQUENCE IF EXISTS SP_INBOUND_AUTH_SEQ;
            CREATE SEQUENCE SP_INBOUND_AUTH_SEQ;
            CREATE TABLE SP_INBOUND_AUTH (
                        ID INTEGER DEFAULT NEXTVAL('SP_INBOUND_AUTH_SEQ'),
                        TENANT_ID INTEGER NOT NULL,
                        INBOUND_AUTH_KEY VARCHAR (255),
                        INBOUND_AUTH_TYPE VARCHAR (255) NOT NULL,
                        INBOUND_CONFIG_TYPE VARCHAR (255) NOT NULL,
                        PROP_NAME VARCHAR (255),
                        PROP_VALUE VARCHAR (1024) ,
                        APP_ID INTEGER NOT NULL,
                        PRIMARY KEY (ID));

            ALTER TABLE SP_INBOUND_AUTH ADD CONSTRAINT APPLICATION_ID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_AUTH_STEP;
            DROP SEQUENCE IF EXISTS SP_AUTH_STEP_SEQ;
            CREATE SEQUENCE SP_AUTH_STEP_SEQ;
            CREATE TABLE SP_AUTH_STEP (
                        ID INTEGER DEFAULT NEXTVAL('SP_AUTH_STEP_SEQ'),
                        TENANT_ID INTEGER NOT NULL,
            	     	STEP_ORDER INTEGER DEFAULT 1,
                        APP_ID INTEGER NOT NULL,
                        IS_SUBJECT_STEP CHAR(1) DEFAULT '0',
                        IS_ATTRIBUTE_STEP CHAR(1) DEFAULT '0',
                        PRIMARY KEY (ID));

            ALTER TABLE SP_AUTH_STEP ADD CONSTRAINT APPLICATION_ID_CONSTRAINT_STEP FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_FEDERATED_IDP;
            CREATE TABLE SP_FEDERATED_IDP (
                        ID INTEGER NOT NULL,
                        TENANT_ID INTEGER NOT NULL,
                        AUTHENTICATOR_ID INTEGER NOT NULL,
                        PRIMARY KEY (ID, AUTHENTICATOR_ID));

            ALTER TABLE SP_FEDERATED_IDP ADD CONSTRAINT STEP_ID_CONSTRAINT FOREIGN KEY (ID) REFERENCES SP_AUTH_STEP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_CLAIM_DIALECT;
            DROP SEQUENCE IF EXISTS SP_CLAIM_DIALECT_SEQ;
            CREATE SEQUENCE SP_CLAIM_DIALECT_SEQ;
            CREATE TABLE SP_CLAIM_DIALECT (
            	    	ID INTEGER DEFAULT NEXTVAL('SP_CLAIM_DIALECT_SEQ'),
            	    	TENANT_ID INTEGER NOT NULL,
            	    	SP_DIALECT VARCHAR (512) NOT NULL,
            	   		APP_ID INTEGER NOT NULL,
                    PRIMARY KEY (ID));

            ALTER TABLE SP_CLAIM_DIALECT ADD CONSTRAINT DIALECTID_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_CLAIM_MAPPING;
            DROP SEQUENCE IF EXISTS SP_CLAIM_MAPPING_SEQ;
            CREATE SEQUENCE SP_CLAIM_MAPPING_SEQ;
            CREATE TABLE SP_CLAIM_MAPPING (
            	    	ID INTEGER DEFAULT NEXTVAL('SP_CLAIM_MAPPING_SEQ'),
            	    	TENANT_ID INTEGER NOT NULL,
            	    	IDP_CLAIM VARCHAR (512) NOT NULL ,
                        SP_CLAIM VARCHAR (512) NOT NULL ,
            	   		APP_ID INTEGER NOT NULL,
            	    	IS_REQUESTED VARCHAR(128) DEFAULT '0',
            		IS_MANDATORY VARCHAR(128) DEFAULT '0',
            	    	DEFAULT_VALUE VARCHAR(255),
                        PRIMARY KEY (ID));

            ALTER TABLE SP_CLAIM_MAPPING ADD CONSTRAINT CLAIMID_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_ROLE_MAPPING;
            DROP SEQUENCE IF EXISTS SP_ROLE_MAPPING_SEQ;
            CREATE SEQUENCE SP_ROLE_MAPPING_SEQ;
            CREATE TABLE SP_ROLE_MAPPING (
            	    	ID INTEGER DEFAULT NEXTVAL('SP_ROLE_MAPPING_SEQ'),
            	    	TENANT_ID INTEGER NOT NULL,
            	    	IDP_ROLE VARCHAR (255) NOT NULL ,
                        SP_ROLE VARCHAR (255) NOT NULL ,
            	    	APP_ID INTEGER NOT NULL,
                        PRIMARY KEY (ID));

            ALTER TABLE SP_ROLE_MAPPING ADD CONSTRAINT ROLEID_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_REQ_PATH_AUTH;
            DROP SEQUENCE IF EXISTS SP_REQ_PATH_AUTH_SEQ;
            CREATE SEQUENCE SP_REQ_PATH_AUTH_SEQ;
            CREATE TABLE SP_REQ_PATH_AUTHENTICATOR (
            	    	ID INTEGER DEFAULT NEXTVAL('SP_REQ_PATH_AUTH_SEQ'),
            	    	TENANT_ID INTEGER NOT NULL,
            	    	AUTHENTICATOR_NAME VARCHAR (255) NOT NULL ,
            	    	APP_ID INTEGER NOT NULL,
                        PRIMARY KEY (ID));

            ALTER TABLE SP_REQ_PATH_AUTHENTICATOR ADD CONSTRAINT REQ_AUTH_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_PROV_CONNECTOR;
            DROP SEQUENCE IF EXISTS SP_PROV_CONNECTOR_SEQ;
            CREATE SEQUENCE SP_PROV_CONNECTOR_SEQ;
            CREATE TABLE SP_PROVISIONING_CONNECTOR (
            	    	ID INTEGER DEFAULT NEXTVAL('SP_PROV_CONNECTOR_SEQ'),
            	    	TENANT_ID INTEGER NOT NULL,
                        IDP_NAME VARCHAR (255) NOT NULL ,
            	    	CONNECTOR_NAME VARCHAR (255) NOT NULL ,
            	    	APP_ID INTEGER NOT NULL,
            	    	IS_JIT_ENABLED CHAR(1) NOT NULL DEFAULT '0',
            		    BLOCKING CHAR(1) NOT NULL DEFAULT '0',
            		    RULE_ENABLED CHAR(1) NOT NULL DEFAULT '0',
                        PRIMARY KEY (ID));

            ALTER TABLE SP_PROVISIONING_CONNECTOR ADD CONSTRAINT PRO_CONNECTOR_APPID_CONSTRAINT FOREIGN KEY (APP_ID) REFERENCES SP_APP (ID) ON DELETE CASCADE;

            DROP TABLE IF EXISTS SP_AUTH_SCRIPT;
            DROP SEQUENCE IF EXISTS SP_AUTH_SCRIPT_SEQ;
            CREATE SEQUENCE SP_AUTH_SCRIPT_SEQ;
            CREATE TABLE SP_AUTH_SCRIPT (
              ID         INTEGER      NOT NULL DEFAULT NEXTVAL('SP_AUTH_SCRIPT_SEQ'),
              TENANT_ID  INTEGER      NOT NULL,
              APP_ID     INTEGER      NOT NULL,
              TYPE       VARCHAR(255) NOT NULL,
              CONTENT    BYTEA                 DEFAULT NULL,
              IS_ENABLED CHAR(1) NOT NULL DEFAULT '0',
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS SP_TEMPLATE;
            DROP SEQUENCE IF EXISTS SP_TEMPLATE_SEQ;
            CREATE SEQUENCE SP_TEMPLATE_SEQ;
            CREATE TABLE SP_TEMPLATE (
              ID         INTEGER NOT NULL DEFAULT NEXTVAL('SP_TEMPLATE_SEQ'),
              TENANT_ID  INTEGER NOT NULL,
              NAME VARCHAR(255) NOT NULL,
              DESCRIPTION VARCHAR(1023),
              CONTENT BYTEA DEFAULT NULL,
              PRIMARY KEY (ID),
              CONSTRAINT SP_TEMPLATE_CONSTRAINT UNIQUE (TENANT_ID, NAME)
            );
            CREATE INDEX IDX_SP_TEMPLATE ON SP_TEMPLATE (TENANT_ID, NAME);

            DROP TABLE IF EXISTS IDN_AUTH_WAIT_STATUS;
            DROP SEQUENCE IF EXISTS IDN_AUTH_WAIT_STATUS_SEQ;
            CREATE SEQUENCE IDN_AUTH_WAIT_STATUS_SEQ;
            CREATE TABLE IDN_AUTH_WAIT_STATUS (
              ID              INTEGER       NOT NULL DEFAULT NEXTVAL('IDN_AUTH_WAIT_STATUS_SEQ'),
              TENANT_ID       INTEGER       NOT NULL,
              LONG_WAIT_KEY   VARCHAR(255)  NOT NULL,
              WAIT_STATUS     CHAR(1) NOT NULL DEFAULT '1',
              TIME_CREATED    TIMESTAMP,
              EXPIRE_TIME     TIMESTAMP,
              PRIMARY KEY (ID),
              CONSTRAINT IDN_AUTH_WAIT_STATUS_KEY UNIQUE (LONG_WAIT_KEY)
            );

            DROP TABLE IF EXISTS IDP;
            DROP SEQUENCE IF EXISTS IDP_SEQ;
            CREATE SEQUENCE IDP_SEQ;
            CREATE TABLE IDP (
            			ID INTEGER DEFAULT NEXTVAL('IDP_SEQ'),
            			TENANT_ID INTEGER,
            			NAME VARCHAR(254) NOT NULL,
            			IS_ENABLED CHAR(1) NOT NULL DEFAULT '1',
            			IS_PRIMARY CHAR(1) NOT NULL DEFAULT '0',
            			HOME_REALM_ID VARCHAR(254),
            			IMAGE BYTEA,
            			CERTIFICATE BYTEA,
            			ALIAS VARCHAR(254),
            			INBOUND_PROV_ENABLED CHAR (1) NOT NULL DEFAULT '0',
            			INBOUND_PROV_USER_STORE_ID VARCHAR(254),
             			USER_CLAIM_URI VARCHAR(254),
             			ROLE_CLAIM_URI VARCHAR(254),
              			DESCRIPTION VARCHAR (1024),
             			DEFAULT_AUTHENTICATOR_NAME VARCHAR(254),
             			DEFAULT_PRO_CONNECTOR_NAME VARCHAR(254),
             			PROVISIONING_ROLE VARCHAR(128),
             			IS_FEDERATION_HUB CHAR(1) NOT NULL DEFAULT '0',
             			IS_LOCAL_CLAIM_DIALECT CHAR(1) NOT NULL DEFAULT '0',
            	                DISPLAY_NAME VARCHAR(255),
            			PRIMARY KEY (ID),
            			UNIQUE (TENANT_ID, NAME));

            DROP TABLE IF EXISTS IDP_ROLE;
            DROP SEQUENCE IF EXISTS IDP_ROLE_SEQ;
            CREATE SEQUENCE IDP_ROLE_SEQ;
            CREATE TABLE IDP_ROLE (
            			ID INTEGER DEFAULT NEXTVAL('IDP_ROLE_SEQ'),
            			IDP_ID INTEGER,
            			TENANT_ID INTEGER,
            			ROLE VARCHAR(254),
            			PRIMARY KEY (ID),
            			UNIQUE (IDP_ID, ROLE),
            			FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_ROLE_MAPPING;
            DROP SEQUENCE IF EXISTS IDP_ROLE_MAPPING_SEQ;
            CREATE SEQUENCE IDP_ROLE_MAPPING_SEQ;
            CREATE TABLE IDP_ROLE_MAPPING (
            			ID INTEGER DEFAULT NEXTVAL('IDP_ROLE_MAPPING_SEQ'),
            			IDP_ROLE_ID INTEGER,
            			TENANT_ID INTEGER,
            			USER_STORE_ID VARCHAR (253),
            			LOCAL_ROLE VARCHAR(253),
            			PRIMARY KEY (ID),
            			UNIQUE (IDP_ROLE_ID, TENANT_ID, USER_STORE_ID, LOCAL_ROLE),
            			FOREIGN KEY (IDP_ROLE_ID) REFERENCES IDP_ROLE(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_CLAIM;
            DROP SEQUENCE IF EXISTS IDP_CLAIM_SEQ;
            CREATE SEQUENCE IDP_CLAIM_SEQ;
            CREATE TABLE IDP_CLAIM (
            			ID INTEGER DEFAULT NEXTVAL('IDP_CLAIM_SEQ'),
            			IDP_ID INTEGER,
            			TENANT_ID INTEGER,
            			CLAIM VARCHAR(254),
            			PRIMARY KEY (ID),
            			UNIQUE (IDP_ID, CLAIM),
            			FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_CLAIM_MAPPING;
            DROP SEQUENCE IF EXISTS IDP_CLAIM_MAPPING_SEQ;
            CREATE SEQUENCE IDP_CLAIM_MAPPING_SEQ;
            CREATE TABLE IDP_CLAIM_MAPPING (
            			ID INTEGER DEFAULT NEXTVAL('IDP_CLAIM_MAPPING_SEQ'),
            			IDP_CLAIM_ID INTEGER,
            			TENANT_ID INTEGER,
            			LOCAL_CLAIM VARCHAR(253),
            		    DEFAULT_VALUE VARCHAR(255),
            	    	IS_REQUESTED VARCHAR(128) DEFAULT '0',
            			PRIMARY KEY (ID),
            			UNIQUE (IDP_CLAIM_ID, TENANT_ID, LOCAL_CLAIM),
            			FOREIGN KEY (IDP_CLAIM_ID) REFERENCES IDP_CLAIM(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_AUTHENTICATOR;
            DROP SEQUENCE IF EXISTS IDP_AUTHENTICATOR_SEQ;
            CREATE SEQUENCE IDP_AUTHENTICATOR_SEQ;
            CREATE TABLE IDP_AUTHENTICATOR (
                        ID INTEGER DEFAULT NEXTVAL('IDP_AUTHENTICATOR_SEQ'),
                        TENANT_ID INTEGER,
                        IDP_ID INTEGER,
                        NAME VARCHAR(255) NOT NULL,
                        IS_ENABLED CHAR (1) DEFAULT '1',
                        DISPLAY_NAME VARCHAR(255),
                        PRIMARY KEY (ID),
                        UNIQUE (TENANT_ID, IDP_ID, NAME),
                        FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_METADATA;
            DROP SEQUENCE IF EXISTS IDP_METADATA_SEQ;
            CREATE SEQUENCE IDP_METADATA_SEQ;
            CREATE TABLE IDP_METADATA (
                        ID INTEGER DEFAULT NEXTVAL('IDP_METADATA_SEQ'),
                        IDP_ID INTEGER,
                        NAME VARCHAR(255) NOT NULL,
                        VALUE VARCHAR(255) NOT NULL,
                        DISPLAY_NAME VARCHAR(255),
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (ID),
                        CONSTRAINT IDP_METADATA_CONSTRAINT UNIQUE (IDP_ID, NAME),
                        FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_AUTHENTICATOR_PROP;
            DROP SEQUENCE IF EXISTS IDP_AUTHENTICATOR_PROP_SEQ;
            CREATE SEQUENCE IDP_AUTHENTICATOR_PROP_SEQ;
            CREATE TABLE IDP_AUTHENTICATOR_PROPERTY (
                        ID INTEGER DEFAULT NEXTVAL('IDP_AUTHENTICATOR_PROP_SEQ'),
                        TENANT_ID INTEGER,
                        AUTHENTICATOR_ID INTEGER,
                        PROPERTY_KEY VARCHAR(255) NOT NULL,
                        PROPERTY_VALUE VARCHAR(2047),
                        IS_SECRET CHAR (1) DEFAULT '0',
                        PRIMARY KEY (ID),
                        UNIQUE (TENANT_ID, AUTHENTICATOR_ID, PROPERTY_KEY),
                        FOREIGN KEY (AUTHENTICATOR_ID) REFERENCES IDP_AUTHENTICATOR(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_PROV_CONFIG;
            DROP SEQUENCE IF EXISTS IDP_PROV_CONFIG_SEQ;
            CREATE SEQUENCE IDP_PROV_CONFIG_SEQ;
            CREATE TABLE IDP_PROVISIONING_CONFIG (
                        ID INTEGER DEFAULT NEXTVAL('IDP_PROV_CONFIG_SEQ'),
                        TENANT_ID INTEGER,
                        IDP_ID INTEGER,
                        PROVISIONING_CONNECTOR_TYPE VARCHAR(255) NOT NULL,
                        IS_ENABLED CHAR (1) DEFAULT '0',
                        IS_BLOCKING CHAR (1) DEFAULT '0',
                        IS_RULES_ENABLED CHAR (1) DEFAULT '0',
                        PRIMARY KEY (ID),
                        UNIQUE (TENANT_ID, IDP_ID, PROVISIONING_CONNECTOR_TYPE),
                        FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_PROV_CONFIG_PROP;
            DROP SEQUENCE IF EXISTS IDP_PROV_CONFIG_PROP_SEQ;
            CREATE SEQUENCE IDP_PROV_CONFIG_PROP_SEQ;
            CREATE TABLE IDP_PROV_CONFIG_PROPERTY (
                        ID INTEGER DEFAULT NEXTVAL('IDP_PROV_CONFIG_PROP_SEQ'),
                        TENANT_ID INTEGER,
                        PROVISIONING_CONFIG_ID INTEGER,
                        PROPERTY_KEY VARCHAR(255) NOT NULL,
                        PROPERTY_VALUE VARCHAR(2048),
                        PROPERTY_BLOB_VALUE BYTEA,
                        PROPERTY_TYPE CHAR(32) NOT NULL,
                        IS_SECRET CHAR (1) DEFAULT '0',
                        PRIMARY KEY (ID),
                        UNIQUE (TENANT_ID, PROVISIONING_CONFIG_ID, PROPERTY_KEY),
                        FOREIGN KEY (PROVISIONING_CONFIG_ID) REFERENCES IDP_PROVISIONING_CONFIG(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_PROV_ENTITY;
            DROP SEQUENCE IF EXISTS IDP_PROV_ENTITY_SEQ;
            CREATE SEQUENCE IDP_PROV_ENTITY_SEQ;
            CREATE TABLE IDP_PROVISIONING_ENTITY (
                        ID INTEGER DEFAULT NEXTVAL('IDP_PROV_ENTITY_SEQ'),
                        PROVISIONING_CONFIG_ID INTEGER,
                        ENTITY_TYPE VARCHAR(255) NOT NULL,
                        ENTITY_LOCAL_USERSTORE VARCHAR(255) NOT NULL,
                        ENTITY_NAME VARCHAR(255) NOT NULL,
                        ENTITY_VALUE VARCHAR(255),
                        TENANT_ID INTEGER,
                        ENTITY_LOCAL_ID VARCHAR(255),
                        PRIMARY KEY (ID),
                        UNIQUE (ENTITY_TYPE, TENANT_ID, ENTITY_LOCAL_USERSTORE, ENTITY_NAME, PROVISIONING_CONFIG_ID),
                        UNIQUE (PROVISIONING_CONFIG_ID, ENTITY_TYPE, ENTITY_VALUE),
                        FOREIGN KEY (PROVISIONING_CONFIG_ID) REFERENCES IDP_PROVISIONING_CONFIG(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDP_LOCAL_CLAIM;
            DROP SEQUENCE IF EXISTS IDP_LOCAL_CLAIM_SEQ;
            CREATE SEQUENCE IDP_LOCAL_CLAIM_SEQ;
            CREATE TABLE IF NOT EXISTS IDP_LOCAL_CLAIM(
                        ID INTEGER DEFAULT NEXTVAL('IDP_LOCAL_CLAIM_SEQ'),
                        TENANT_ID INTEGER,
                        IDP_ID INTEGER,
                        CLAIM_URI VARCHAR(255) NOT NULL,
                        DEFAULT_VALUE VARCHAR(255),
            	        IS_REQUESTED VARCHAR(128) DEFAULT '0',
                        PRIMARY KEY (ID),
                        UNIQUE (TENANT_ID, IDP_ID, CLAIM_URI),
                        FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE);

            DROP TABLE IF EXISTS IDN_ASSOCIATED_ID;
            DROP SEQUENCE IF EXISTS IDN_ASSOCIATED_ID_SEQ;
            CREATE SEQUENCE IDN_ASSOCIATED_ID_SEQ;
            CREATE TABLE IDN_ASSOCIATED_ID (
                        ID INTEGER DEFAULT NEXTVAL('IDN_ASSOCIATED_ID_SEQ'),
            	    IDP_USER_ID VARCHAR(255) NOT NULL,
                        TENANT_ID INTEGER DEFAULT -1234,
            	    IDP_ID INTEGER NOT NULL,
                        DOMAIN_NAME VARCHAR(255) NOT NULL,
             	    USER_NAME VARCHAR(255) NOT NULL,
            	    PRIMARY KEY (ID),
                        UNIQUE(IDP_USER_ID, TENANT_ID, IDP_ID),
                        FOREIGN KEY (IDP_ID) REFERENCES IDP(ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_USER_ACCOUNT_ASSOCIATION;
            CREATE TABLE IDN_USER_ACCOUNT_ASSOCIATION (
                        ASSOCIATION_KEY VARCHAR(255) NOT NULL,
                        TENANT_ID INTEGER,
                        DOMAIN_NAME VARCHAR(255) NOT NULL,
                        USER_NAME VARCHAR(255) NOT NULL,
                        PRIMARY KEY (TENANT_ID, DOMAIN_NAME, USER_NAME));

            DROP TABLE IF EXISTS FIDO_DEVICE_STORE;
            CREATE TABLE FIDO_DEVICE_STORE (
                    TENANT_ID INTEGER,
                    DOMAIN_NAME VARCHAR(255) NOT NULL,
                    USER_NAME VARCHAR(45) NOT NULL,
            	TIME_REGISTERED TIMESTAMP,
                    KEY_HANDLE VARCHAR(200) NOT NULL,
                    DEVICE_DATA VARCHAR(2048) NOT NULL,
                  PRIMARY KEY (TENANT_ID, DOMAIN_NAME, USER_NAME, KEY_HANDLE));

            DROP TABLE IF EXISTS WF_REQUEST;
            CREATE TABLE WF_REQUEST (
                UUID VARCHAR (45),
                CREATED_BY VARCHAR (255),
                TENANT_ID INTEGER DEFAULT -1,
                OPERATION_TYPE VARCHAR (50),
                CREATED_AT TIMESTAMP,
                UPDATED_AT TIMESTAMP,
                STATUS VARCHAR (30),
                REQUEST BYTEA,
                PRIMARY KEY (UUID)
            );

            DROP TABLE IF EXISTS WF_BPS_PROFILE;
            CREATE TABLE WF_BPS_PROFILE (
                PROFILE_NAME VARCHAR(45),
                HOST_URL_MANAGER VARCHAR(255),
                HOST_URL_WORKER VARCHAR(255),
                USERNAME VARCHAR(45),
                PASSWORD VARCHAR(1023),
                CALLBACK_HOST VARCHAR (45),
                TENANT_ID INTEGER DEFAULT -1,
                PRIMARY KEY (PROFILE_NAME, TENANT_ID)
            );

            DROP TABLE IF EXISTS WF_WORKFLOW;
            CREATE TABLE WF_WORKFLOW(
                ID VARCHAR (45),
                WF_NAME VARCHAR (45),
                DESCRIPTION VARCHAR (255),
                TEMPLATE_ID VARCHAR (45),
                IMPL_ID VARCHAR (45),
                TENANT_ID INTEGER DEFAULT -1,
                PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS WF_WORKFLOW_ASSOCIATION;
            DROP SEQUENCE IF EXISTS WF_WORKFLOW_ASSOCIATION_PK_SEQ;
            CREATE SEQUENCE WF_WORKFLOW_ASSOCIATION_PK_SEQ;
            CREATE TABLE WF_WORKFLOW_ASSOCIATION(
                ID INTEGER DEFAULT NEXTVAL('WF_WORKFLOW_ASSOCIATION_PK_SEQ'),
                ASSOC_NAME VARCHAR (45),
                EVENT_ID VARCHAR(45),
                ASSOC_CONDITION VARCHAR (2000),
                WORKFLOW_ID VARCHAR (45),
                IS_ENABLED CHAR (1) DEFAULT '1',
                TENANT_ID INTEGER DEFAULT -1,
                PRIMARY KEY(ID),
                FOREIGN KEY (WORKFLOW_ID) REFERENCES WF_WORKFLOW(ID)ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS WF_WORKFLOW_CONFIG_PARAM;
            CREATE TABLE WF_WORKFLOW_CONFIG_PARAM(
                WORKFLOW_ID VARCHAR (45),
                PARAM_NAME VARCHAR (45),
                PARAM_VALUE VARCHAR (1000),
                PARAM_QNAME VARCHAR (45),
                PARAM_HOLDER VARCHAR (45),
                TENANT_ID INTEGER DEFAULT -1,
                PRIMARY KEY (WORKFLOW_ID, PARAM_NAME, PARAM_QNAME, PARAM_HOLDER),
                FOREIGN KEY (WORKFLOW_ID) REFERENCES WF_WORKFLOW(ID)ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS WF_REQUEST_ENTITY_RELATIONSHIP;
            CREATE TABLE WF_REQUEST_ENTITY_RELATIONSHIP(
              REQUEST_ID VARCHAR (45),
              ENTITY_NAME VARCHAR (255),
              ENTITY_TYPE VARCHAR (50),
              TENANT_ID INTEGER DEFAULT -1,
              PRIMARY KEY(REQUEST_ID, ENTITY_NAME, ENTITY_TYPE, TENANT_ID),
              FOREIGN KEY (REQUEST_ID) REFERENCES WF_REQUEST(UUID)ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS WF_WORKFLOW_REQUEST_RELATION;
            CREATE TABLE WF_WORKFLOW_REQUEST_RELATION(
              RELATIONSHIP_ID VARCHAR (45),
              WORKFLOW_ID VARCHAR (45),
              REQUEST_ID VARCHAR (45),
              UPDATED_AT TIMESTAMP,
              STATUS VARCHAR (30),
              TENANT_ID INTEGER DEFAULT -1,
              PRIMARY KEY (RELATIONSHIP_ID),
              FOREIGN KEY (WORKFLOW_ID) REFERENCES WF_WORKFLOW(ID)ON DELETE CASCADE,
              FOREIGN KEY (REQUEST_ID) REFERENCES WF_REQUEST(UUID)ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_RECOVERY_DATA;
            CREATE TABLE IDN_RECOVERY_DATA (
              USER_NAME VARCHAR(255) NOT NULL,
              USER_DOMAIN VARCHAR(127) NOT NULL,
              TENANT_ID INTEGER DEFAULT -1,
              CODE VARCHAR(255) NOT NULL,
              SCENARIO VARCHAR(255) NOT NULL,
              STEP VARCHAR(127) NOT NULL,
              TIME_CREATED TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
              REMAINING_SETS VARCHAR(2500) DEFAULT NULL,
              PRIMARY KEY(USER_NAME, USER_DOMAIN, TENANT_ID, SCENARIO,STEP),
              UNIQUE(CODE)
            );

            DROP TABLE IF EXISTS IDN_PASSWORD_HISTORY_DATA;
            CREATE SEQUENCE IDN_PASSWORD_HISTORY_DATA_PK_SEQ;
            CREATE TABLE IDN_PASSWORD_HISTORY_DATA (
              ID INTEGER DEFAULT NEXTVAL('IDN_PASSWORD_HISTORY_DATA_PK_SEQ'),
              USER_NAME   VARCHAR(255) NOT NULL,
              USER_DOMAIN VARCHAR(127) NOT NULL,
              TENANT_ID   INTEGER DEFAULT -1,
              SALT_VALUE  VARCHAR(255),
              HASH        VARCHAR(255) NOT NULL,
              TIME_CREATED TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
              PRIMARY KEY (ID),
              UNIQUE (USER_NAME,USER_DOMAIN,TENANT_ID,SALT_VALUE,HASH)
            );

            DROP TABLE IF EXISTS IDN_CLAIM_DIALECT;
            DROP SEQUENCE IF EXISTS IDN_CLAIM_DIALECT_SEQ;
            CREATE SEQUENCE IDN_CLAIM_DIALECT_SEQ;
            CREATE TABLE IDN_CLAIM_DIALECT (
              ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_DIALECT_SEQ'),
              DIALECT_URI VARCHAR (255) NOT NULL,
              TENANT_ID INTEGER NOT NULL,
              PRIMARY KEY (ID),
              CONSTRAINT DIALECT_URI_CONSTRAINT UNIQUE (DIALECT_URI, TENANT_ID)
            );

            DROP TABLE IF EXISTS IDN_CLAIM;
            DROP SEQUENCE IF EXISTS IDN_CLAIM_SEQ;
            CREATE SEQUENCE IDN_CLAIM_SEQ;
            CREATE TABLE IDN_CLAIM (
              ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_SEQ'),
              DIALECT_ID INTEGER,
              CLAIM_URI VARCHAR (255) NOT NULL,
              TENANT_ID INTEGER NOT NULL,
              PRIMARY KEY (ID),
              FOREIGN KEY (DIALECT_ID) REFERENCES IDN_CLAIM_DIALECT(ID) ON DELETE CASCADE,
              CONSTRAINT CLAIM_URI_CONSTRAINT UNIQUE (DIALECT_ID, CLAIM_URI, TENANT_ID)
            );

            DROP TABLE IF EXISTS IDN_CLAIM_MAPPED_ATTRIBUTE;
            DROP SEQUENCE IF EXISTS IDN_CLAIM_MAPPED_ATTRIBUTE_SEQ;
            CREATE SEQUENCE IDN_CLAIM_MAPPED_ATTRIBUTE_SEQ;
            CREATE TABLE IDN_CLAIM_MAPPED_ATTRIBUTE (
              ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_MAPPED_ATTRIBUTE_SEQ'),
              LOCAL_CLAIM_ID INTEGER,
              USER_STORE_DOMAIN_NAME VARCHAR (255) NOT NULL,
              ATTRIBUTE_NAME VARCHAR (255) NOT NULL,
              TENANT_ID INTEGER NOT NULL,
              PRIMARY KEY (ID),
              FOREIGN KEY (LOCAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
              CONSTRAINT USER_STORE_DOMAIN_CONSTRAINT UNIQUE (LOCAL_CLAIM_ID, USER_STORE_DOMAIN_NAME, TENANT_ID)
            );

            DROP TABLE IF EXISTS IDN_CLAIM_PROPERTY;
            DROP SEQUENCE IF EXISTS IDN_CLAIM_PROPERTY_SEQ;
            CREATE SEQUENCE IDN_CLAIM_PROPERTY_SEQ;
            CREATE TABLE IDN_CLAIM_PROPERTY (
              ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_PROPERTY_SEQ'),
              LOCAL_CLAIM_ID INTEGER,
              PROPERTY_NAME VARCHAR (255) NOT NULL,
              PROPERTY_VALUE VARCHAR (255) NOT NULL,
              TENANT_ID INTEGER NOT NULL,
              PRIMARY KEY (ID),
              FOREIGN KEY (LOCAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
              CONSTRAINT PROPERTY_NAME_CONSTRAINT UNIQUE (LOCAL_CLAIM_ID, PROPERTY_NAME, TENANT_ID)
            );

            DROP TABLE IF EXISTS IDN_CLAIM_MAPPING;
            DROP SEQUENCE IF EXISTS IDN_CLAIM_MAPPING_SEQ;
            CREATE SEQUENCE IDN_CLAIM_MAPPING_SEQ;
            CREATE TABLE IDN_CLAIM_MAPPING (
              ID INTEGER DEFAULT NEXTVAL('IDN_CLAIM_MAPPING_SEQ'),
              EXT_CLAIM_ID INTEGER NOT NULL,
              MAPPED_LOCAL_CLAIM_ID INTEGER NOT NULL,
              TENANT_ID INTEGER NOT NULL,
              PRIMARY KEY (ID),
              FOREIGN KEY (EXT_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
              FOREIGN KEY (MAPPED_LOCAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE,
              CONSTRAINT EXT_TO_LOC_MAPPING_CONSTRN UNIQUE (EXT_CLAIM_ID, TENANT_ID)
            );

            DROP TABLE IF EXISTS IDN_SAML2_ASSERTION_STORE;
            DROP SEQUENCE IF EXISTS IDN_SAML2_ASSERTION_STORE_SEQ;
            CREATE SEQUENCE IDN_SAML2_ASSERTION_STORE_SEQ;
            CREATE TABLE IDN_SAML2_ASSERTION_STORE (
              ID INTEGER DEFAULT NEXTVAL('IDN_SAML2_ASSERTION_STORE_SEQ'),
              SAML2_ID  VARCHAR(255) ,
              SAML2_ISSUER  VARCHAR(255) ,
              SAML2_SUBJECT  VARCHAR(255) ,
              SAML2_SESSION_INDEX  VARCHAR(255) ,
              SAML2_AUTHN_CONTEXT_CLASS_REF  VARCHAR(255) ,
              SAML2_ASSERTION  VARCHAR(4096) ,
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS IDN_SAML2_ARTIFACT_STORE;
            DROP SEQUENCE IF EXISTS IDN_SAML2_ARTIFACT_STORE_SEQ;
            CREATE SEQUENCE IDN_SAML2_ARTIFACT_STORE_SEQ;
            CREATE TABLE IDN_SAML2_ARTIFACT_STORE (
              ID INTEGER DEFAULT NEXTVAL('IDN_SAML2_ARTIFACT_STORE_SEQ'),
              SOURCE_ID VARCHAR(255) NOT NULL,
              MESSAGE_HANDLER VARCHAR(255) NOT NULL,
              AUTHN_REQ_DTO BYTEA NOT NULL,
              SESSION_ID VARCHAR(255) NOT NULL,
              INIT_TIMESTAMP TIMESTAMP NOT NULL,
              EXP_TIMESTAMP TIMESTAMP NOT NULL,
              ASSERTION_ID VARCHAR(255),
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS IDN_OIDC_JTI;
            CREATE TABLE IDN_OIDC_JTI (
              JWT_ID VARCHAR(255) NOT NULL,
              EXP_TIME TIMESTAMP NOT NULL,
              TIME_CREATED TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
              PRIMARY KEY (JWT_ID)
            );

            DROP TABLE IF EXISTS IDN_OIDC_PROPERTY;
            DROP SEQUENCE IF EXISTS IDN_OIDC_PROPERTY_SEQ;
            CREATE SEQUENCE IDN_OIDC_PROPERTY_SEQ;
            CREATE TABLE IDN_OIDC_PROPERTY (
              ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_PROPERTY_SEQ'),
              TENANT_ID  INTEGER,
              CONSUMER_KEY  VARCHAR(255) ,
              PROPERTY_KEY  VARCHAR(255) NOT NULL,
              PROPERTY_VALUE  VARCHAR(2047) ,
              PRIMARY KEY (ID) ,
              FOREIGN KEY (CONSUMER_KEY) REFERENCES IDN_OAUTH_CONSUMER_APPS(CONSUMER_KEY) ON DELETE CASCADE
            );
            DROP TABLE IF EXISTS IDN_OIDC_REQ_OBJECT_REFERENCE;
            DROP SEQUENCE IF EXISTS IDN_OIDC_REQUEST_OBJECT_REF_SEQ;
            CREATE SEQUENCE IDN_OIDC_REQUEST_OBJECT_REF_SEQ;
            CREATE TABLE IDN_OIDC_REQ_OBJECT_REFERENCE (
              ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_REQUEST_OBJECT_REF_SEQ'),
              CONSUMER_KEY_ID INTEGER ,
              CODE_ID VARCHAR(255) ,
              TOKEN_ID VARCHAR(255) ,
              SESSION_DATA_KEY VARCHAR(255),
              PRIMARY KEY (ID),
              FOREIGN KEY (CONSUMER_KEY_ID) REFERENCES IDN_OAUTH_CONSUMER_APPS(ID) ON DELETE CASCADE,
              FOREIGN KEY (TOKEN_ID) REFERENCES IDN_OAUTH2_ACCESS_TOKEN(TOKEN_ID) ON DELETE CASCADE,
              FOREIGN KEY (CODE_ID) REFERENCES IDN_OAUTH2_AUTHORIZATION_CODE(CODE_ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_OIDC_REQ_OBJECT_CLAIMS;
            DROP SEQUENCE IF EXISTS IDN_OIDC_REQ_OBJECT_CLAIMS_SEQ;
            CREATE SEQUENCE IDN_OIDC_REQ_OBJECT_CLAIMS_SEQ;
            CREATE TABLE IDN_OIDC_REQ_OBJECT_CLAIMS (
              ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_REQ_OBJECT_CLAIMS_SEQ'),
              REQ_OBJECT_ID INTEGER,
              CLAIM_ATTRIBUTE VARCHAR(255) ,
              ESSENTIAL CHAR(1) NOT NULL DEFAULT '0' ,
              VALUE VARCHAR(255) ,
              IS_USERINFO CHAR(1) NOT NULL DEFAULT '0',
              PRIMARY KEY (ID),
              FOREIGN KEY (REQ_OBJECT_ID) REFERENCES IDN_OIDC_REQ_OBJECT_REFERENCE (ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_OIDC_REQ_OBJ_CLAIM_VALUES;
            DROP SEQUENCE IF EXISTS IDN_OIDC_REQ_OBJECT_CLAIM_VALUES_SEQ;
            CREATE SEQUENCE IDN_OIDC_REQ_OBJECT_CLAIM_VALUES_SEQ;
            CREATE TABLE IDN_OIDC_REQ_OBJ_CLAIM_VALUES (
              ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_REQ_OBJECT_CLAIM_VALUES_SEQ'),
              REQ_OBJECT_CLAIMS_ID INTEGER ,
              CLAIM_VALUES VARCHAR(255) ,
              PRIMARY KEY (ID),
              FOREIGN KEY (REQ_OBJECT_CLAIMS_ID) REFERENCES IDN_OIDC_REQ_OBJECT_CLAIMS(ID) ON DELETE CASCADE
            );

            DROP TABLE IF EXISTS IDN_CERTIFICATE;
            DROP SEQUENCE IF EXISTS IDN_CERTIFICATE_PK_SEQ;
            CREATE SEQUENCE IDN_CERTIFICATE_PK_SEQ;
            CREATE TABLE IDN_CERTIFICATE (
                        ID INTEGER DEFAULT NEXTVAL('IDN_CERTIFICATE_PK_SEQ'),
                        NAME VARCHAR(100),
                        CERTIFICATE_IN_PEM BYTEA,
                        TENANT_ID INTEGER DEFAULT 0,
                        CONSTRAINT CERTIFICATE_UNIQUE_KEY UNIQUE (NAME, TENANT_ID),
                        PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS IDN_OIDC_SCOPE;
            DROP SEQUENCE IF EXISTS IDN_OIDC_SCOPE_PK_SEQ;
            CREATE SEQUENCE IDN_OIDC_SCOPE_PK_SEQ;
            CREATE TABLE IDN_OIDC_SCOPE (
                        ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_SCOPE_PK_SEQ'),
                        NAME VARCHAR(255),
                        TENANT_ID INTEGER DEFAULT -1,
                        PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS IDN_OIDC_SCOPE_CLAIM_MAPPING;
            DROP SEQUENCE IF EXISTS IDN_OIDC_SCOPE_CLAIM_MAPPING_PK_SEQ;
            CREATE SEQUENCE IDN_OIDC_SCOPE_CLAIM_MAPPING_PK_SEQ;
            CREATE TABLE IDN_OIDC_SCOPE_CLAIM_MAPPING (
                        ID INTEGER DEFAULT NEXTVAL('IDN_OIDC_SCOPE_CLAIM_MAPPING_PK_SEQ'),
                        SCOPE_ID INTEGER,
                        EXTERNAL_CLAIM_ID INTEGER,
                        PRIMARY KEY (ID),
                        FOREIGN KEY (SCOPE_ID) REFERENCES IDN_OIDC_SCOPE(ID) ON DELETE CASCADE,
                        FOREIGN KEY (EXTERNAL_CLAIM_ID) REFERENCES IDN_CLAIM(ID) ON DELETE CASCADE
            );

            CREATE INDEX IDX_AT_SI_ECI ON IDN_OIDC_SCOPE_CLAIM_MAPPING(SCOPE_ID, EXTERNAL_CLAIM_ID);

            -- End of IDENTITY Tables--

            -- Start of CONSENT-MGT Tables --
            DROP TABLE IF EXISTS CM_PII_CATEGORY;
            DROP SEQUENCE IF EXISTS CM_PII_CATEGORY_PK_SEQ;
            CREATE SEQUENCE CM_PII_CATEGORY_PK_SEQ;
            CREATE TABLE CM_PII_CATEGORY (
              ID           INTEGER DEFAULT NEXTVAL('CM_PII_CATEGORY_PK_SEQ'),
              NAME         VARCHAR(255) NOT NULL,
              DESCRIPTION  VARCHAR(1023),
              DISPLAY_NAME VARCHAR(255),
              IS_SENSITIVE INTEGER      NOT NULL,
              TENANT_ID    INTEGER DEFAULT '-1234',
              CONSTRAINT CM_PII_CATEGORY_CNT UNIQUE (NAME, TENANT_ID),
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS CM_RECEIPT;
            CREATE TABLE CM_RECEIPT (
              CONSENT_RECEIPT_ID  VARCHAR(255) NOT NULL,
              VERSION             VARCHAR(255) NOT NULL,
              JURISDICTION        VARCHAR(255) NOT NULL,
              CONSENT_TIMESTAMP   TIMESTAMP    NOT NULL,
              COLLECTION_METHOD   VARCHAR(255) NOT NULL,
              LANGUAGE            VARCHAR(255) NOT NULL,
              PII_PRINCIPAL_ID    VARCHAR(255) NOT NULL,
              PRINCIPAL_TENANT_ID INTEGER DEFAULT '-1234',
              POLICY_URL          VARCHAR(255) NOT NULL,
              STATE               VARCHAR(255) NOT NULL,
              PII_CONTROLLER      VARCHAR(2048) NOT NULL,
              PRIMARY KEY (CONSENT_RECEIPT_ID)
            );

            DROP TABLE IF EXISTS CM_PURPOSE;
            DROP SEQUENCE IF EXISTS CM_PURPOSE_PK_SEQ;
            CREATE SEQUENCE CM_PURPOSE_PK_SEQ;
            CREATE TABLE CM_PURPOSE (
              ID            INTEGER DEFAULT NEXTVAL('CM_PURPOSE_PK_SEQ'),
              NAME          VARCHAR(255) NOT NULL,
              DESCRIPTION   VARCHAR(1023),
              PURPOSE_GROUP VARCHAR(255) NOT NULL,
              GROUP_TYPE    VARCHAR(255) NOT NULL,
              TENANT_ID     INTEGER DEFAULT '-1234',
              CONSTRAINT CM_PURPOSE_CNT UNIQUE  (NAME, TENANT_ID, PURPOSE_GROUP, GROUP_TYPE),
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS CM_PURPOSE_CATEGORY;
            DROP SEQUENCE IF EXISTS CM_PURPOSE_CATEGORY_PK_SEQ;
            CREATE SEQUENCE CM_PURPOSE_CATEGORY_PK_SEQ;
            CREATE TABLE CM_PURPOSE_CATEGORY (
              ID          INTEGER DEFAULT NEXTVAL('CM_PURPOSE_CATEGORY_PK_SEQ'),
              NAME        VARCHAR(255) NOT NULL,
              DESCRIPTION VARCHAR(1023),
              TENANT_ID   INTEGER DEFAULT '-1234',
              CONSTRAINT CM_PURPOSE_CATEGORY_CNT UNIQUE  (NAME, TENANT_ID),
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS CM_RECEIPT_SP_ASSOC;
            DROP SEQUENCE IF EXISTS CM_RECEIPT_SP_ASSOC_PK_SEQ;
            CREATE SEQUENCE CM_RECEIPT_SP_ASSOC_PK_SEQ;
            CREATE TABLE CM_RECEIPT_SP_ASSOC (
              ID                 INTEGER DEFAULT NEXTVAL('CM_RECEIPT_SP_ASSOC_PK_SEQ'),
              CONSENT_RECEIPT_ID VARCHAR(255) NOT NULL,
              SP_NAME            VARCHAR(255) NOT NULL,
              SP_DISPLAY_NAME    VARCHAR(255),
              SP_DESCRIPTION     VARCHAR(255),
              SP_TENANT_ID       INTEGER DEFAULT '-1234',
              CONSTRAINT CM_RECEIPT_SP_ASSOC_CNT UNIQUE  (CONSENT_RECEIPT_ID, SP_NAME, SP_TENANT_ID),
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS CM_SP_PURPOSE_ASSOC;
            DROP SEQUENCE IF EXISTS CM_SP_PURPOSE_ASSOC_PK_SEQ;
            CREATE SEQUENCE CM_SP_PURPOSE_ASSOC_PK_SEQ;
            CREATE TABLE CM_SP_PURPOSE_ASSOC (
              ID                     INTEGER DEFAULT NEXTVAL('CM_SP_PURPOSE_ASSOC_PK_SEQ'),
              RECEIPT_SP_ASSOC       INTEGER      NOT NULL,
              PURPOSE_ID             INTEGER      NOT NULL,
              CONSENT_TYPE           VARCHAR(255) NOT NULL,
              IS_PRIMARY_PURPOSE     INTEGER      NOT NULL,
              TERMINATION            VARCHAR(255) NOT NULL,
              THIRD_PARTY_DISCLOSURE INTEGER      NOT NULL,
              THIRD_PARTY_NAME       VARCHAR(255),
              CONSTRAINT CM_SP_PURPOSE_ASSOC_CNT UNIQUE  (RECEIPT_SP_ASSOC, PURPOSE_ID),
              PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS CM_SP_PURPOSE_PURPOSE_CAT_ASSC;
            CREATE TABLE CM_SP_PURPOSE_PURPOSE_CAT_ASSC (
              SP_PURPOSE_ASSOC_ID INTEGER NOT NULL,
              PURPOSE_CATEGORY_ID INTEGER NOT NULL,
              CONSTRAINT CM_SP_PURPOSE_PURPOSE_CAT_ASSC_CNT UNIQUE  (SP_PURPOSE_ASSOC_ID, PURPOSE_CATEGORY_ID)
            );

            DROP TABLE IF EXISTS CM_PURPOSE_PII_CAT_ASSOC;
            CREATE TABLE CM_PURPOSE_PII_CAT_ASSOC (
              PURPOSE_ID         INTEGER NOT NULL,
              CM_PII_CATEGORY_ID INTEGER NOT NULL,
              IS_MANDATORY       INTEGER NOT NULL,
              CONSTRAINT CM_PURPOSE_PII_CAT_ASSOC_CNT UNIQUE  (PURPOSE_ID, CM_PII_CATEGORY_ID)
            );

            DROP TABLE IF EXISTS CM_SP_PURPOSE_PII_CAT_ASSOC;
            CREATE TABLE CM_SP_PURPOSE_PII_CAT_ASSOC (
              SP_PURPOSE_ASSOC_ID INTEGER NOT NULL,
              PII_CATEGORY_ID     INTEGER NOT NULL,
              VALIDITY            VARCHAR(1023),
              CONSTRAINT CM_SP_PURPOSE_PII_CAT_ASSOC_CNT UNIQUE  (SP_PURPOSE_ASSOC_ID, PII_CATEGORY_ID)
            );

            DROP TABLE IF EXISTS CM_CONSENT_RECEIPT_PROPERTY;
            CREATE TABLE CM_CONSENT_RECEIPT_PROPERTY (
              CONSENT_RECEIPT_ID VARCHAR(255)  NOT NULL,
              NAME               VARCHAR(255)  NOT NULL,
              VALUE              VARCHAR(1023) NOT NULL,
              CONSTRAINT CM_CONSENT_RECEIPT_PROPERTY_CNT UNIQUE  (CONSENT_RECEIPT_ID, NAME)
            );

            ALTER TABLE CM_RECEIPT_SP_ASSOC
              ADD CONSTRAINT CM_RECEIPT_SP_ASSOC_fk0 FOREIGN KEY (CONSENT_RECEIPT_ID) REFERENCES CM_RECEIPT (CONSENT_RECEIPT_ID);

            ALTER TABLE CM_SP_PURPOSE_ASSOC
              ADD CONSTRAINT CM_SP_PURPOSE_ASSOC_fk0 FOREIGN KEY (RECEIPT_SP_ASSOC) REFERENCES CM_RECEIPT_SP_ASSOC (ID);

            ALTER TABLE CM_SP_PURPOSE_ASSOC
              ADD CONSTRAINT CM_SP_PURPOSE_ASSOC_fk1 FOREIGN KEY (PURPOSE_ID) REFERENCES CM_PURPOSE (ID);

            ALTER TABLE CM_SP_PURPOSE_PURPOSE_CAT_ASSC
              ADD CONSTRAINT CM_SP_P_P_CAT_ASSOC_fk0 FOREIGN KEY (SP_PURPOSE_ASSOC_ID) REFERENCES CM_SP_PURPOSE_ASSOC (ID);

            ALTER TABLE CM_SP_PURPOSE_PURPOSE_CAT_ASSC
              ADD CONSTRAINT CM_SP_P_P_CAT_ASSOC_fk1 FOREIGN KEY (PURPOSE_CATEGORY_ID) REFERENCES CM_PURPOSE_CATEGORY (ID);

            ALTER TABLE CM_SP_PURPOSE_PII_CAT_ASSOC
              ADD CONSTRAINT CM_SP_P_PII_CAT_ASSOC_fk0 FOREIGN KEY (SP_PURPOSE_ASSOC_ID) REFERENCES CM_SP_PURPOSE_ASSOC (ID);

            ALTER TABLE CM_SP_PURPOSE_PII_CAT_ASSOC
              ADD CONSTRAINT CM_SP_P_PII_CAT_ASSOC_fk1 FOREIGN KEY (PII_CATEGORY_ID) REFERENCES CM_PII_CATEGORY (ID);

            ALTER TABLE CM_CONSENT_RECEIPT_PROPERTY
              ADD CONSTRAINT CM_CONSENT_RECEIPT_PRT_fk0 FOREIGN KEY (CONSENT_RECEIPT_ID) REFERENCES CM_RECEIPT (CONSENT_RECEIPT_ID);

            INSERT INTO CM_PURPOSE (NAME, DESCRIPTION, PURPOSE_GROUP, GROUP_TYPE, TENANT_ID) VALUES ('DEFAULT', 'For core functionalities of the product', 'DEFAULT', 'SP', '-1234');

            INSERT INTO CM_PURPOSE_CATEGORY (NAME, DESCRIPTION, TENANT_ID) VALUES ('DEFAULT','For core functionalities of the product', '-1234');
            -- End of CONSENT-MGT Tables --

            CREATE SEQUENCE AM_SUBSCRIBER_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_SUBSCRIBER (
                SUBSCRIBER_ID INTEGER DEFAULT nextval('am_subscriber_sequence'),
                USER_ID VARCHAR(50) NOT NULL,
                TENANT_ID INTEGER NOT NULL,
                EMAIL_ADDRESS VARCHAR(256) NULL,
                DATE_SUBSCRIBED TIMESTAMP NOT NULL,
                CREATED_BY VARCHAR(100),
                CREATED_TIME TIMESTAMP,
                UPDATED_BY VARCHAR(100),
                UPDATED_TIME TIMESTAMP,
                PRIMARY KEY (SUBSCRIBER_ID),
                UNIQUE (TENANT_ID,USER_ID)
            )
            ;

            CREATE SEQUENCE AM_APPLICATION_SEQUENCE START WITH 1 INCREMENT BY 1 ;
            CREATE TABLE IF NOT EXISTS AM_APPLICATION (
                APPLICATION_ID INTEGER DEFAULT nextval('am_application_sequence'),
                NAME VARCHAR(100),
                SUBSCRIBER_ID INTEGER,
                APPLICATION_TIER VARCHAR(50) DEFAULT 'Unlimited',
                CALLBACK_URL VARCHAR(512),
                DESCRIPTION VARCHAR(512),
                APPLICATION_STATUS VARCHAR(50) DEFAULT 'APPROVED',
                GROUP_ID VARCHAR(100),
                CREATED_BY VARCHAR(100),
                CREATED_TIME TIMESTAMP,
                UPDATED_BY VARCHAR(100),
                UPDATED_TIME TIMESTAMP,
                UUID VARCHAR(256),
                TOKEN_TYPE VARCHAR(10),
                FOREIGN KEY(SUBSCRIBER_ID) REFERENCES AM_SUBSCRIBER(SUBSCRIBER_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY(APPLICATION_ID),
                UNIQUE (NAME,SUBSCRIBER_ID),
                UNIQUE (UUID)
            )
            ;

            CREATE SEQUENCE AM_API_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_API (
                API_ID INTEGER DEFAULT nextval('am_api_sequence'),
                API_PROVIDER VARCHAR(256),
                API_NAME VARCHAR(256),
                API_VERSION VARCHAR(30),
                CONTEXT VARCHAR(256),
                CONTEXT_TEMPLATE VARCHAR(256),
                API_TIER VARCHAR(256),
                CREATED_BY VARCHAR(100),
                CREATED_TIME TIMESTAMP,
                UPDATED_BY VARCHAR(100),
                UPDATED_TIME TIMESTAMP,
                PRIMARY KEY(API_ID),
                UNIQUE (API_PROVIDER,API_NAME,API_VERSION)
            );

            CREATE SEQUENCE AM_API_URL_MAPPING_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_API_URL_MAPPING (
                URL_MAPPING_ID INTEGER DEFAULT nextval('am_api_url_mapping_sequence'),
                API_ID INTEGER NOT NULL,
                HTTP_METHOD VARCHAR(20) NULL,
                AUTH_SCHEME VARCHAR(50) NULL,
                URL_PATTERN VARCHAR(512) NULL,
                THROTTLING_TIER varchar(512) DEFAULT NULL,
                MEDIATION_SCRIPT BYTEA,
                PRIMARY KEY(URL_MAPPING_ID)
            )
            ;

            CREATE SEQUENCE AM_SUBSCRIPTION_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_SUBSCRIPTION (
                SUBSCRIPTION_ID INTEGER DEFAULT nextval('am_subscription_sequence'),
                TIER_ID VARCHAR(50),
                API_ID INTEGER,
                LAST_ACCESSED TIMESTAMP NULL,
                APPLICATION_ID INTEGER,
                SUB_STATUS VARCHAR(50),
                SUBS_CREATE_STATE VARCHAR(50) DEFAULT 'SUBSCRIBE',
                CREATED_BY VARCHAR(100),
                CREATED_TIME TIMESTAMP,
                UPDATED_BY VARCHAR(100),
                UPDATED_TIME TIMESTAMP,
                UUID VARCHAR(256),
                FOREIGN KEY(APPLICATION_ID) REFERENCES AM_APPLICATION(APPLICATION_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                FOREIGN KEY(API_ID) REFERENCES AM_API(API_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY (SUBSCRIPTION_ID),
                UNIQUE (UUID)
            )
            ;

            CREATE TABLE IF NOT EXISTS AM_SUBSCRIPTION_KEY_MAPPING (
                SUBSCRIPTION_ID INTEGER,
                ACCESS_TOKEN VARCHAR(512),
                KEY_TYPE VARCHAR(512) NOT NULL,
                FOREIGN KEY(SUBSCRIPTION_ID) REFERENCES AM_SUBSCRIPTION(SUBSCRIPTION_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY(SUBSCRIPTION_ID,ACCESS_TOKEN)
            )
            ;

            CREATE TABLE AM_APPLICATION_KEY_MAPPING (
                APPLICATION_ID INTEGER,
                CONSUMER_KEY VARCHAR(512),
                KEY_TYPE VARCHAR(512) NOT NULL,
                STATE VARCHAR(30),
                CREATE_MODE VARCHAR(30) DEFAULT 'CREATED',
                FOREIGN KEY(APPLICATION_ID) REFERENCES AM_APPLICATION(APPLICATION_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY(APPLICATION_ID,KEY_TYPE)
            )
            ;

            CREATE SEQUENCE AM_APPLICATION_REGISTRATION_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_APPLICATION_REGISTRATION (
                REG_ID INTEGER DEFAULT nextval('am_application_registration_sequence'),
                SUBSCRIBER_ID INT,
                WF_REF VARCHAR(255) NOT NULL,
                APP_ID INT,
                TOKEN_TYPE VARCHAR(30),
                TOKEN_SCOPE VARCHAR(1500) DEFAULT 'default',
                INPUTS VARCHAR(1000),
                ALLOWED_DOMAINS VARCHAR(256),
                VALIDITY_PERIOD BIGINT,
                UNIQUE (SUBSCRIBER_ID,APP_ID,TOKEN_TYPE),
                FOREIGN KEY(SUBSCRIBER_ID) REFERENCES AM_SUBSCRIBER(SUBSCRIBER_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                FOREIGN KEY(APP_ID) REFERENCES AM_APPLICATION(APPLICATION_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY (REG_ID)
            )
            ;



            CREATE SEQUENCE AM_API_LC_EVENT_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_API_LC_EVENT (
                EVENT_ID INTEGER DEFAULT nextval('am_api_lc_event_sequence'),
                API_ID INTEGER NOT NULL,
                PREVIOUS_STATE VARCHAR(50),
                NEW_STATE VARCHAR(50) NOT NULL,
                USER_ID VARCHAR(50) NOT NULL,
                TENANT_ID INTEGER NOT NULL,
                EVENT_DATE TIMESTAMP NOT NULL,
                FOREIGN KEY(API_ID) REFERENCES AM_API(API_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY (EVENT_ID)
            )
            ;

            CREATE TABLE IF NOT EXISTS AM_APP_KEY_DOMAIN_MAPPING (
               CONSUMER_KEY VARCHAR(255),
               AUTHZ_DOMAIN VARCHAR(255) DEFAULT 'ALL',
               PRIMARY KEY (CONSUMER_KEY,AUTHZ_DOMAIN)
            )
            ;

            CREATE SEQUENCE AM_API_COMMENTS_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_API_COMMENTS (
                COMMENT_ID INTEGER DEFAULT nextval('am_api_comments_sequence'),
                COMMENT_TEXT VARCHAR(512),
                COMMENTED_USER VARCHAR(255),
                DATE_COMMENTED TIMESTAMP NOT NULL,
                API_ID INTEGER NOT NULL,
                FOREIGN KEY(API_ID) REFERENCES AM_API(API_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY (COMMENT_ID)
            )
            ;

            CREATE SEQUENCE AM_WORKFLOWS_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_WORKFLOWS(
                WF_ID INTEGER DEFAULT nextval('am_workflows_sequence'),
                WF_REFERENCE VARCHAR(255) NOT NULL,
                WF_TYPE VARCHAR(255) NOT NULL,
                WF_STATUS VARCHAR(255) NOT NULL,
                WF_CREATED_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                WF_UPDATED_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP ,
                WF_STATUS_DESC VARCHAR(1000),
                TENANT_ID INTEGER,
                TENANT_DOMAIN VARCHAR(255),
                WF_EXTERNAL_REFERENCE VARCHAR(255) NOT NULL,
                PRIMARY KEY (WF_ID),
                UNIQUE (WF_EXTERNAL_REFERENCE)
            )
            ;

            CREATE SEQUENCE AM_API_RATINGS_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_API_RATINGS (
                RATING_ID INTEGER DEFAULT nextval('am_api_ratings_sequence'),
                API_ID INTEGER,
                RATING INTEGER,
                SUBSCRIBER_ID INTEGER,
                FOREIGN KEY(API_ID) REFERENCES AM_API(API_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                FOREIGN KEY(SUBSCRIBER_ID) REFERENCES AM_SUBSCRIBER(SUBSCRIBER_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY (RATING_ID)
            )
            ;

            CREATE SEQUENCE AM_TIER_PERMISSIONS_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_TIER_PERMISSIONS (
                TIER_PERMISSIONS_ID INTEGER DEFAULT nextval('am_tier_permissions_sequence'),
                TIER VARCHAR(50) NOT NULL,
                PERMISSIONS_TYPE VARCHAR(50) NOT NULL,
                ROLES VARCHAR(512) NOT NULL,
                TENANT_ID INTEGER NOT NULL,
                PRIMARY KEY(TIER_PERMISSIONS_ID)
            );

            CREATE SEQUENCE AM_EXTERNAL_STORES_SEQUENCE START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_EXTERNAL_STORES (
                APISTORE_ID INTEGER DEFAULT nextval('am_external_stores_sequence'),
                API_ID INTEGER,
                STORE_ID VARCHAR(255) NOT NULL,
                STORE_DISPLAY_NAME VARCHAR(255) NOT NULL,
                STORE_ENDPOINT VARCHAR(255) NOT NULL,
                STORE_TYPE VARCHAR(255) NOT NULL,
                FOREIGN KEY(API_ID) REFERENCES AM_API(API_ID) ON UPDATE CASCADE ON DELETE RESTRICT,
                PRIMARY KEY (APISTORE_ID)
            )
            ;


            CREATE TABLE IF NOT EXISTS AM_API_SCOPES (
               API_ID  INTEGER NOT NULL,
               SCOPE_ID  INTEGER NOT NULL,
               FOREIGN KEY (API_ID) REFERENCES AM_API (API_ID) ON DELETE CASCADE  ON UPDATE CASCADE,
               FOREIGN KEY (SCOPE_ID) REFERENCES IDN_OAUTH2_SCOPE (SCOPE_ID) ON DELETE CASCADE ON UPDATE CASCADE,
               PRIMARY KEY (API_ID, SCOPE_ID)
            );


            CREATE SEQUENCE AM_API_DEFAULT_VERSION_PK_SEQ;
            CREATE TABLE IF NOT EXISTS AM_API_DEFAULT_VERSION (
                        DEFAULT_VERSION_ID INTEGER DEFAULT NEXTVAL('am_api_default_version_pk_seq'),
                        API_NAME VARCHAR(256) NOT NULL ,
                        API_PROVIDER VARCHAR(256) NOT NULL ,
                        DEFAULT_API_VERSION VARCHAR(30) ,
                        PUBLISHED_DEFAULT_API_VERSION VARCHAR(30) ,
                        PRIMARY KEY (DEFAULT_VERSION_ID)
            );


            CREATE INDEX IDX_SUB_APP_ID ON AM_SUBSCRIPTION (APPLICATION_ID, SUBSCRIPTION_ID)
            ;

            CREATE SEQUENCE AM_ALERT_TYPES_SEQ START WITH 1 INCREMENT BY 1;

            CREATE TABLE IF NOT EXISTS AM_ALERT_TYPES (
                        ALERT_TYPE_ID INTEGER DEFAULT NEXTVAL('am_alert_types_seq'),
                        ALERT_TYPE_NAME VARCHAR(255) NOT NULL ,
            	    STAKE_HOLDER VARCHAR(100) NOT NULL,
                        PRIMARY KEY (ALERT_TYPE_ID)
            );

            CREATE TABLE IF NOT EXISTS AM_ALERT_TYPES_VALUES (
                        ALERT_TYPE_ID INTEGER,
                        USER_NAME VARCHAR(255) NOT NULL ,
            	    STAKE_HOLDER VARCHAR(100) NOT NULL ,
                        CONSTRAINT AM_ALERT_TYPES_VALUES_CONST UNIQUE (ALERT_TYPE_ID,USER_NAME,STAKE_HOLDER)
            );

            CREATE SEQUENCE AM_ALERT_EMAILLIST_SEQ START WITH 1 INCREMENT BY 1;

            CREATE TABLE IF NOT EXISTS AM_ALERT_EMAILLIST (
            	    EMAIL_LIST_ID INTEGER DEFAULT NEXTVAL('am_alert_emaillist_seq'),
                        USER_NAME VARCHAR(255) NOT NULL ,
            	    STAKE_HOLDER VARCHAR(100) NOT NULL ,
                        CONSTRAINT AM_ALERT_EMAILLIST_CONST UNIQUE (EMAIL_LIST_ID,USER_NAME,STAKE_HOLDER),
                        PRIMARY KEY (EMAIL_LIST_ID)
            );

            CREATE TABLE IF NOT EXISTS  AM_ALERT_EMAILLIST_DETAILS (
                        EMAIL_LIST_ID INTEGER,
            	    EMAIL VARCHAR(255),
                        CONSTRAINT AM_ALERT_EMAILLIST_DETAILS_CONST UNIQUE (EMAIL_LIST_ID,EMAIL)
            );

            INSERT INTO AM_ALERT_TYPES (ALERT_TYPE_NAME, STAKE_HOLDER) VALUES ('AbnormalResponseTime', 'publisher');
            INSERT INTO AM_ALERT_TYPES (ALERT_TYPE_NAME, STAKE_HOLDER) VALUES ('AbnormalBackendTime', 'publisher');
            INSERT INTO AM_ALERT_TYPES (ALERT_TYPE_NAME, STAKE_HOLDER) VALUES ('AbnormalRequestsPerMin', 'subscriber');
            INSERT INTO AM_ALERT_TYPES (ALERT_TYPE_NAME, STAKE_HOLDER) VALUES ('AbnormalRequestPattern', 'subscriber');
            INSERT INTO AM_ALERT_TYPES (ALERT_TYPE_NAME, STAKE_HOLDER) VALUES ('UnusualIPAccess', 'subscriber');
            INSERT INTO AM_ALERT_TYPES (ALERT_TYPE_NAME, STAKE_HOLDER) VALUES ('FrequentTierLimitHitting', 'subscriber');
            INSERT INTO AM_ALERT_TYPES (ALERT_TYPE_NAME, STAKE_HOLDER) VALUES ('ApiHealthMonitor', 'publisher');



            -- AM Throttling tables --
            CREATE SEQUENCE AM_POLICY_SUBSCRIPTION_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_POLICY_SUBSCRIPTION (
                        POLICY_ID INTEGER DEFAULT NEXTVAL('AM_POLICY_SUBSCRIPTION_SEQ'),
                        NAME VARCHAR(512) NOT NULL,
                        DISPLAY_NAME VARCHAR(512) NULL DEFAULT NULL,
                        TENANT_ID INTEGER NOT NULL,
                        DESCRIPTION VARCHAR(1024) NULL DEFAULT NULL,
                        QUOTA_TYPE VARCHAR(25) NOT NULL,
                        QUOTA INTEGER NOT NULL,
                        QUOTA_UNIT VARCHAR(10) NULL,
                        UNIT_TIME INTEGER NOT NULL,
                        TIME_UNIT VARCHAR(25) NOT NULL,
                        RATE_LIMIT_COUNT INTEGER NULL DEFAULT NULL,
                        RATE_LIMIT_TIME_UNIT VARCHAR(25) NULL DEFAULT NULL,
                        IS_DEPLOYED BOOLEAN NOT NULL DEFAULT '0',
            			      CUSTOM_ATTRIBUTES BYTEA DEFAULT NULL,
                        STOP_ON_QUOTA_REACH BOOLEAN NOT NULL DEFAULT '0',
                        BILLING_PLAN VARCHAR(20) NOT NULL,
                        UUID VARCHAR(256),
                        PRIMARY KEY (POLICY_ID),
                        UNIQUE (NAME, TENANT_ID),
                        UNIQUE (UUID)
            );

            CREATE SEQUENCE AM_POLICY_APPLICATION_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_POLICY_APPLICATION (
                        POLICY_ID INTEGER DEFAULT NEXTVAL('AM_POLICY_APPLICATION_SEQ'),
                        NAME VARCHAR(512) NOT NULL,
                        DISPLAY_NAME VARCHAR(512) NULL DEFAULT NULL,
                        TENANT_ID INTEGER NOT NULL,
                        DESCRIPTION VARCHAR(1024) NULL DEFAULT NULL,
                        QUOTA_TYPE VARCHAR(25) NOT NULL,
                        QUOTA INTEGER NOT NULL,
                        QUOTA_UNIT VARCHAR(10) NULL DEFAULT NULL,
                        UNIT_TIME INTEGER NOT NULL,
                        TIME_UNIT VARCHAR(25) NOT NULL,
                        IS_DEPLOYED BOOLEAN NOT NULL DEFAULT '0',
            			CUSTOM_ATTRIBUTES BYTEA DEFAULT NULL,
            			      UUID VARCHAR(256),
                        PRIMARY KEY (POLICY_ID),
                        UNIQUE  (NAME, TENANT_ID),
                        UNIQUE (UUID)
            );

            CREATE SEQUENCE AM_POLICY_HARD_THROTTLING_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_POLICY_HARD_THROTTLING (
                        POLICY_ID INTEGER DEFAULT NEXTVAL('AM_POLICY_HARD_THROTTLING_SEQ'),
                        NAME VARCHAR(512) NOT NULL,
                        TENANT_ID INTEGER NOT NULL,
                        DESCRIPTION VARCHAR(1024) NULL DEFAULT NULL,
                        QUOTA_TYPE VARCHAR(25) NOT NULL,
                        QUOTA INTEGER NOT NULL,
                        QUOTA_UNIT VARCHAR(10) NULL DEFAULT NULL,
                        UNIT_TIME INTEGER NOT NULL,
                        TIME_UNIT VARCHAR(25) NOT NULL,
                        IS_DEPLOYED BOOLEAN NOT NULL DEFAULT '0',
                        PRIMARY KEY (POLICY_ID),
                        UNIQUE  (NAME, TENANT_ID)
            );

            CREATE SEQUENCE AM_API_THROTTLE_POLICY_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_API_THROTTLE_POLICY (
                        POLICY_ID INTEGER DEFAULT NEXTVAL('AM_API_THROTTLE_POLICY_SEQ'),
                        NAME VARCHAR(512) NOT NULL,
                        DISPLAY_NAME VARCHAR(512) NULL DEFAULT NULL,
                        TENANT_ID INTEGER NOT NULL,
                        DESCRIPTION VARCHAR (1024),
                        DEFAULT_QUOTA_TYPE VARCHAR(25) NOT NULL,
                        DEFAULT_QUOTA INTEGER NOT NULL,
                        DEFAULT_QUOTA_UNIT VARCHAR(10) NULL,
                        DEFAULT_UNIT_TIME INTEGER NOT NULL,
                        DEFAULT_TIME_UNIT VARCHAR(25) NOT NULL,
                        APPLICABLE_LEVEL VARCHAR(25) NOT NULL,
                        IS_DEPLOYED BOOLEAN NOT NULL DEFAULT '0',
                        UUID VARCHAR(256),
                        PRIMARY KEY (POLICY_ID),
                        UNIQUE  (NAME, TENANT_ID),
                        UNIQUE (UUID)
            );

            CREATE SEQUENCE AM_CONDITION_GROUP_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_CONDITION_GROUP (
                        CONDITION_GROUP_ID INTEGER DEFAULT NEXTVAL('AM_CONDITION_GROUP_SEQ'),
                        POLICY_ID INTEGER NOT NULL,
                        QUOTA_TYPE VARCHAR(25),
                        QUOTA INTEGER NOT NULL,
                        QUOTA_UNIT VARCHAR(10) NULL DEFAULT NULL,
                        UNIT_TIME INTEGER NOT NULL,
                        TIME_UNIT VARCHAR(25) NOT NULL,
                        DESCRIPTION VARCHAR (1024) NULL DEFAULT NULL,
                        PRIMARY KEY (CONDITION_GROUP_ID),
                        FOREIGN KEY (POLICY_ID) REFERENCES AM_API_THROTTLE_POLICY(POLICY_ID) ON DELETE CASCADE ON UPDATE CASCADE
            );

            CREATE SEQUENCE AM_QUERY_PARAMETER_CONDITION_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_QUERY_PARAMETER_CONDITION (
                        QUERY_PARAMETER_ID INTEGER DEFAULT NEXTVAL('AM_QUERY_PARAMETER_CONDITION_SEQ'),
                        CONDITION_GROUP_ID INTEGER NOT NULL,
                        PARAMETER_NAME VARCHAR(255) DEFAULT NULL,
                        PARAMETER_VALUE VARCHAR(255) DEFAULT NULL,
            	    	IS_PARAM_MAPPING BOOLEAN DEFAULT '1',
                        PRIMARY KEY (QUERY_PARAMETER_ID),
                        FOREIGN KEY (CONDITION_GROUP_ID) REFERENCES AM_CONDITION_GROUP(CONDITION_GROUP_ID) ON DELETE CASCADE ON UPDATE CASCADE
            );

            CREATE SEQUENCE AM_HEADER_FIELD_CONDITION_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_HEADER_FIELD_CONDITION (
                        HEADER_FIELD_ID INTEGER DEFAULT NEXTVAL('AM_HEADER_FIELD_CONDITION_SEQ'),
                        CONDITION_GROUP_ID INTEGER NOT NULL,
                        HEADER_FIELD_NAME VARCHAR(255) DEFAULT NULL,
                        HEADER_FIELD_VALUE VARCHAR(255) DEFAULT NULL,
            	    	IS_HEADER_FIELD_MAPPING BOOLEAN DEFAULT '1',
                        PRIMARY KEY (HEADER_FIELD_ID),
                        FOREIGN KEY (CONDITION_GROUP_ID) REFERENCES AM_CONDITION_GROUP(CONDITION_GROUP_ID) ON DELETE CASCADE ON UPDATE CASCADE
            );

            CREATE SEQUENCE AM_JWT_CLAIM_CONDITION_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_JWT_CLAIM_CONDITION (
                        JWT_CLAIM_ID INTEGER DEFAULT NEXTVAL('AM_JWT_CLAIM_CONDITION_SEQ'),
                        CONDITION_GROUP_ID INTEGER NOT NULL,
                        CLAIM_URI VARCHAR(512) DEFAULT NULL,
                        CLAIM_ATTRIB VARCHAR(1024) DEFAULT NULL,
            	    IS_CLAIM_MAPPING BOOLEAN DEFAULT '1',
                        PRIMARY KEY (JWT_CLAIM_ID),
                        FOREIGN KEY (CONDITION_GROUP_ID) REFERENCES AM_CONDITION_GROUP(CONDITION_GROUP_ID) ON DELETE CASCADE ON UPDATE CASCADE
            );

            CREATE SEQUENCE AM_IP_CONDITION_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_IP_CONDITION (
              AM_IP_CONDITION_ID INTEGER DEFAULT NEXTVAL('AM_IP_CONDITION_SEQ'),
              STARTING_IP VARCHAR(45) NULL,
              ENDING_IP VARCHAR(45) NULL,
              SPECIFIC_IP VARCHAR(45) NULL,
              WITHIN_IP_RANGE BOOLEAN DEFAULT '1',
              CONDITION_GROUP_ID INT NULL,
              PRIMARY KEY (AM_IP_CONDITION_ID),
              FOREIGN KEY (CONDITION_GROUP_ID)
                REFERENCES AM_CONDITION_GROUP (CONDITION_GROUP_ID)   ON DELETE CASCADE ON UPDATE CASCADE);

            CREATE SEQUENCE AM_POLICY_GLOBAL_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_POLICY_GLOBAL (
                        POLICY_ID INTEGER DEFAULT NEXTVAL('AM_POLICY_GLOBAL_SEQ'),
                        NAME VARCHAR(512) NOT NULL,
                        KEY_TEMPLATE VARCHAR(512) NOT NULL,
                        TENANT_ID INTEGER NOT NULL,
                        DESCRIPTION VARCHAR(1024) NULL DEFAULT NULL,
                        SIDDHI_QUERY BYTEA DEFAULT NULL,
                        IS_DEPLOYED BOOLEAN NOT NULL DEFAULT '0',
                        UUID VARCHAR(256),
                        PRIMARY KEY (POLICY_ID),
                        UNIQUE (UUID)
            );

            CREATE SEQUENCE AM_THROTTLE_TIER_PERMISSIONS_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE IF NOT EXISTS AM_THROTTLE_TIER_PERMISSIONS (
              THROTTLE_TIER_PERMISSIONS_ID INTEGER DEFAULT NEXTVAL('AM_THROTTLE_TIER_PERMISSIONS_SEQ'),
              TIER VARCHAR(50) NULL,
              PERMISSIONS_TYPE VARCHAR(50) NULL,
              ROLES VARCHAR(512) NULL,
              TENANT_ID INTEGER NULL,
              PRIMARY KEY (THROTTLE_TIER_PERMISSIONS_ID));

            CREATE SEQUENCE AM_BLOCK_CONDITIONS_SEQ START WITH 1 INCREMENT BY 1;
            CREATE TABLE AM_BLOCK_CONDITIONS (
              CONDITION_ID INTEGER DEFAULT NEXTVAL('AM_BLOCK_CONDITIONS_SEQ'),
              TYPE varchar(45) DEFAULT NULL,
              VALUE varchar(512) DEFAULT NULL,
              ENABLED varchar(45) DEFAULT NULL,
              DOMAIN varchar(45) DEFAULT NULL,
              UUID VARCHAR(256),
              PRIMARY KEY (CONDITION_ID),
              UNIQUE (UUID)
            );

            DROP TABLE IF EXISTS AM_CERTIFICATE_METADATA;
            CREATE TABLE AM_CERTIFICATE_METADATA (
              TENANT_ID INTEGER NOT NULL,
              ALIAS VARCHAR(45) NOT NULL,
              END_POINT VARCHAR(45) NOT NULL,
              CONSTRAINT PK_ALIAS PRIMARY KEY (ALIAS)
            );

            DROP TABLE IF EXISTS AM_APPLICATION_GROUP_MAPPING;
            CREATE TABLE AM_APPLICATION_GROUP_MAPPING (
                APPLICATION_ID INTEGER NOT NULL,
                GROUP_ID VARCHAR(512) NOT NULL,
                TENANT VARCHAR(255),
                PRIMARY KEY (APPLICATION_ID,GROUP_ID,TENANT),
                FOREIGN KEY (APPLICATION_ID) REFERENCES AM_APPLICATION(APPLICATION_ID) ON DELETE CASCADE ON UPDATE CASCADE
            );

            DROP TABLE IF EXISTS AM_USAGE_UPLOADED_FILES;
            CREATE TABLE AM_USAGE_UPLOADED_FILES (
              TENANT_DOMAIN VARCHAR(255) NOT NULL,
              FILE_NAME VARCHAR(255) NOT NULL,
              FILE_TIMESTAMP TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
              FILE_PROCESSED INTEGER DEFAULT 0,
              FILE_CONTENT BYTEA DEFAULT NULL,
              PRIMARY KEY (TENANT_DOMAIN, FILE_NAME, FILE_TIMESTAMP)
            );

            DROP TABLE IF EXISTS AM_API_LC_PUBLISH_EVENTS;
            DROP SEQUENCE IF EXISTS AM_API_LC_PUBLISH_EVENTS_PK_SEQ;
            CREATE SEQUENCE AM_API_LC_PUBLISH_EVENTS_PK_SEQ;
            CREATE TABLE IF NOT EXISTS AM_API_LC_PUBLISH_EVENTS (
                ID INTEGER NOT NULL DEFAULT NEXTVAL('AM_API_LC_PUBLISH_EVENTS_PK_SEQ'),
                TENANT_DOMAIN VARCHAR(500) NOT NULL,
                API_ID VARCHAR(500) NOT NULL,
                EVENT_TIME TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (ID)
            );

            DROP TABLE IF EXISTS AM_APPLICATION_ATTRIBUTES;
            CREATE TABLE IF NOT EXISTS AM_APPLICATION_ATTRIBUTES (
              APPLICATION_ID INTEGER NOT NULL,
              NAME VARCHAR(255) NOT NULL,
              VALUE VARCHAR(1024) NOT NULL,
              TENANT_ID INTEGER NOT NULL,
              PRIMARY KEY (APPLICATION_ID,NAME),
              FOREIGN KEY (APPLICATION_ID) REFERENCES AM_APPLICATION (APPLICATION_ID) ON DELETE CASCADE ON UPDATE CASCADE
            );

            DROP TABLE IF EXISTS AM_LABELS;
            CREATE TABLE IF NOT EXISTS AM_LABELS (
              LABEL_ID VARCHAR(50),
              NAME VARCHAR(255),
              DESCRIPTION VARCHAR(1024),
              TENANT_DOMAIN VARCHAR(255),
              UNIQUE (NAME,TENANT_DOMAIN),
              PRIMARY KEY (LABEL_ID)
            );

            DROP TABLE IF EXISTS AM_LABEL_URLS;
            CREATE TABLE IF NOT EXISTS AM_LABEL_URLS (
              LABEL_ID VARCHAR(50),
              ACCESS_URL VARCHAR(255),
              PRIMARY KEY (LABEL_ID,ACCESS_URL),
              FOREIGN KEY (LABEL_ID) REFERENCES AM_LABELS(LABEL_ID) ON UPDATE CASCADE ON DELETE CASCADE
            );
            -- End of API-MGT Tables --

            -- Performance indexes start--

            create index IDX_ITS_LMT on IDN_THRIFT_SESSION (LAST_MODIFIED_TIME);
            create index IDX_IOAT_UT on IDN_OAUTH2_ACCESS_TOKEN (USER_TYPE);
            create index IDX_AAI_CTX on AM_API (CONTEXT);
            create index IDX_AAKM_CK on AM_APPLICATION_KEY_MAPPING (CONSUMER_KEY);
            create index IDX_AAUM_AI on AM_API_URL_MAPPING (API_ID);
            create index IDX_AAUM_TT on AM_API_URL_MAPPING (THROTTLING_TIER);
            create index IDX_AATP_DQT on AM_API_THROTTLE_POLICY (DEFAULT_QUOTA_TYPE);
            create index IDX_ACG_QT on AM_CONDITION_GROUP (QUOTA_TYPE);
            create index IDX_APS_QT on AM_POLICY_SUBSCRIPTION (QUOTA_TYPE);
            create index IDX_AS_AITIAI on AM_SUBSCRIPTION (API_ID,TIER_ID,APPLICATION_ID);
            create index IDX_APA_QT on AM_POLICY_APPLICATION (QUOTA_TYPE);
            create index IDX_AA_AT_CB on AM_APPLICATION (APPLICATION_TIER,CREATED_BY);

            -- Performance indexes end--


            commit;"

        ## ConfigMap with scripts to be run at first boot
        ## NOTE: This will override initdbScripts
        # initdbScriptsConfigMap:

        ## Secret with scripts to be run at first boot (in case it contains sensitive information)
        ## NOTE: This can work along initdbScripts or initdbScriptsConfigMap
        # initdbScriptsSecret:

        ## Optional duration in seconds the pod needs to terminate gracefully.
        ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
        ##
        # terminationGracePeriodSeconds: 30

        ## PostgreSQL service configuration
service:
  ## PosgresSQL service type
  type: ClusterIP
  # clusterIP: None
  port: 5432

  ## Specify the nodePort value for the LoadBalancer and NodePort service types.
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  ##
  # nodePort:

  ## Provide any additional annotations which may be required. This can be used to
  annotations: {}
  ## Set the LoadBalancer service type to internal only.
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
  ##
  # loadBalancerIP:

  ## Load Balancer sources
  ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
  ##
  # loadBalancerSourceRanges:
  # - 10.10.10.0/24

## PostgreSQL data Persistent Volume Storage Class
## If defined, storageClassName: <storageClass>
## If set to "-", storageClassName: "", which disables dynamic provisioning
## If undefined (the default) or set to null, no storageClassName spec is
##   set, choosing the default provisioner.  (gp2 on AWS, standard on
##   GKE, AWS & OpenStack)
##
persistence:
  enabled: true
  ## A manually managed Persistent Volume and Claim
  ## If defined, PVC must be created manually before volume will be bound
  ## The value is evaluated as a template, so, for example, the name can depend on .Release or .Chart
  ##
  # existingClaim:

  ## The path the volume will be mounted at, useful when using different
  ## PostgreSQL images.
  ##
  mountPath: /bitnami/postgresql

  ## The subdirectory of the volume to mount to, useful in dev environments
  ## and one PV for multiple services.
  ##
  subPath: ""

  # storageClass: "-"
  accessModes:
    - ReadWriteOnce
  size: 8Gi
  annotations: {}

## updateStrategy for PostgreSQL StatefulSet and its slaves StatefulSets
## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
updateStrategy:
  type: RollingUpdate

##
## PostgreSQL Master parameters
##
master:
  ## Node, affinity and tolerations labels for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  nodeSelector: {}
  affinity: {}
  tolerations: []
  podLabels: {}
  podAnnotations: {}
  ## Additional PostgreSQL Master Volume mounts
  ##
  extraVolumeMounts: []
  ## Additional PostgreSQL Master Volumes
  ##
  extraVolumes: []

##
## PostgreSQL Slave parameters
##
slave:
  ## Node, affinity and tolerations labels for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  nodeSelector: {}
  affinity: {}
  tolerations: []
  podLabels: {}
  podAnnotations: {}
  ## Additional PostgreSQL Slave Volume mounts
  ##
  extraVolumeMounts: []
  ## Additional PostgreSQL Slave Volumes
  ##
  extraVolumes: []

## Configure resource requests and limits
## ref: http://kubernetes.io/docs/user-guide/compute-resources/
##
resources:
  requests:
    memory: 256Mi
    cpu: 250m

networkPolicy:
  ## Enable creation of NetworkPolicy resources.
  ##
  enabled: false

  ## The Policy model to apply. When set to false, only pods with the correct
  ## client label will have network access to the port PostgreSQL is listening
  ## on. When true, PostgreSQL will accept connections from any source
  ## (with the correct destination port).
  ##
  allowExternal: true

## Configure extra options for liveness and readiness probes
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes)
livenessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  enabled: true
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

## Configure metrics exporter
##
metrics:
  enabled: false
  # resources: {}
  service:
    type: ClusterIP
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9187"
    loadBalancerIP:
  serviceMonitor:
    enabled: false
    additionalLabels: {}
    # namespace: monitoring
    # interval: 30s
    # scrapeTimeout: 10s
  image:
    registry: docker.io
    repository: wrouesnel/postgres_exporter
    tag: v0.4.7
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName
  ## Pod Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  ##
  securityContext:
    enabled: false
    runAsUser: 1001
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes)
  ## Configure extra options for liveness and readiness probes
  livenessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1

  readinessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 6
    successThreshold: 1

# Define custom environment variables to pass to the image here
extraEnv: {}
